Index: branch-1.5/backend/ipp.c
===================================================================
--- branch-1.5/backend/ipp.c	(.../branch-1.5/backend/ipp.c)	(revision 10232)
+++ branch-1.4/backend/ipp.c	(.../branch-1.4/backend/ipp.c)	(revision 10232)
@@ -1,9 +1,9 @@
 /*
  * "$Id$"
  *
- *   IPP backend for CUPS.
+ *   IPP backend for the Common UNIX Printing System (CUPS).
  *
- *   Copyright 2007-2011 by Apple Inc.
+ *   Copyright 2007-2010 by Apple Inc.
  *   Copyright 1997-2007 by Easy Software Products, all rights reserved.
  *
  *   These coded instructions, statements, and computer programs are the
@@ -18,16 +18,14 @@
  *
  *   main()                 - Send a file to the printer or server.
  *   cancel_job()           - Cancel a print job.
- *   check_printer_state()  - Check the printer state.
- *   compress_files()       - Compress print files.
- *   monitor_printer()      - Monitor the printer state.
- *   new_request()          - Create a new print creation or validation request.
+ *   check_printer_state()  - Check the printer state...
+ *   compress_files()       - Compress print files...
  *   password_cb()          - Disable the password prompt for
  *                            cupsDoFileRequest().
  *   report_attr()          - Report an IPP attribute value.
  *   report_printer_state() - Report the printer state.
- *   run_as_user()          - Run the IPP backend as the printing user.
- *   timeout_cb()           - Handle HTTP timeouts.
+ *   run_pictwps_filter()   - Convert PICT files to PostScript when printing
+ *                            remotely.
  *   sigterm_handler()      - Handle 'terminate' signals that stop the backend.
  */
 
@@ -35,138 +33,49 @@
  * Include necessary headers.
  */
 
+#include <cups/http-private.h>
 #include "backend-private.h"
-#include <cups/array-private.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
-#if defined(HAVE_GSSAPI) && defined(HAVE_XPC)
-#  include <xpc/xpc.h>
-#  define kPMPrintUIToolAgent	"com.apple.printuitool.agent"
-#  define kPMStartJob		100
-#  define kPMWaitForJob		101
-extern void	xpc_connection_set_target_uid(xpc_connection_t connection,
-		                              uid_t uid);
-#endif /* HAVE_GSSAPI && HAVE_XPC */
 
-
 /*
- * Types...
- */
-
-typedef struct _cups_monitor_s		/**** Monitoring data ****/
-{
-  const char		*uri,		/* Printer URI */
-			*hostname,	/* Hostname */
-			*user,		/* Username */
-			*resource;	/* Resource path */
-  int			port,		/* Port number */
-			version,	/* IPP version */
-			job_id;		/* Job ID for submitted job */
-  http_encryption_t	encryption;	/* Use encryption? */
-  ipp_jstate_t		job_state;	/* Current job state */
-  ipp_pstate_t		printer_state;	/* Current printer state */
-} _cups_monitor_t;
-
-
-/*
  * Globals...
  */
 
-static const char 	*auth_info_required;
+static char	*password = NULL;	/* Password for device URI */
+static int	password_tries = 0;	/* Password tries */
+static const char *auth_info_required = "none";
 					/* New auth-info-required value */
-#if defined(HAVE_GSSAPI) && defined(HAVE_XPC)
-static int		child_pid = 0;	/* Child process ID */
-#endif /* HAVE_GSSAPI && HAVE_XPC */
-static const char * const jattrs[] =	/* Job attributes we want */
-{
-  "job-impressions-completed",
-  "job-media-sheets-completed",
-  "job-state",
-  "job-state-reasons"
-};
-static int		job_canceled = 0;
-					/* Job cancelled? */
-static char		*password = NULL;
-					/* Password for device URI */
-static int		password_tries = 0;
-					/* Password tries */
-static const char * const pattrs[] =	/* Printer attributes we want */
-{
-  "copies-supported",
-  "cups-version",
-  "document-format-supported",
-  "marker-colors",
-  "marker-high-levels",
-  "marker-levels",
-  "marker-low-levels",
-  "marker-message",
-  "marker-names",
-  "marker-types",
-  "media-col-supported",
-  "multiple-document-handling-supported",
-  "operations-supported",
-  "printer-alert",
-  "printer-alert-description",
-  "printer-is-accepting-jobs",
-  "printer-state",
-  "printer-state-message",
-  "printer-state-reasons"
-};
-static const char * const remote_job_states[] =
-{					/* Remote job state keywords */
-  "+cups-remote-pending",
-  "+cups-remote-pending-held",
-  "+cups-remote-processing",
-  "+cups-remote-stopped",
-  "+cups-remote-canceled",
-  "+cups-remote-aborted",
-  "+cups-remote-completed"
-};
-static _cups_mutex_t	report_mutex = _CUPS_MUTEX_INITIALIZER;
-					/* Mutex to control access */
-static int		num_attr_cache = 0;
-					/* Number of cached attributes */
-static cups_option_t	*attr_cache = NULL;
-					/* Cached attributes */
-static cups_array_t	*state_reasons;	/* Array of printe-state-reasons keywords */
-static char		tmpfilename[1024] = "";
-					/* Temporary spool file name */
+#ifdef __APPLE__
+static char	pstmpname[1024] = "";	/* Temporary PostScript file name */
+#endif /* __APPLE__ */
+static char	tmpfilename[1024] = "";	/* Temporary spool file name */
+static int	job_cancelled = 0;	/* Job cancelled? */
 
 
 /*
  * Local functions...
  */
 
-static void		cancel_job(http_t *http, const char *uri, int id,
-			           const char *resource, const char *user,
-				   int version);
-static ipp_pstate_t	check_printer_state(http_t *http, const char *uri,
-		                            const char *resource,
-					    const char *user, int version);
+static void	cancel_job(http_t *http, const char *uri, int id,
+		           const char *resource, const char *user, int version);
+static void	check_printer_state(http_t *http, const char *uri,
+		                    const char *resource, const char *user,
+				    int version, int job_id);
 #ifdef HAVE_LIBZ
-static void		compress_files(int num_files, char **files);
+static void	compress_files(int num_files, char **files);
 #endif /* HAVE_LIBZ */
-static void		*monitor_printer(_cups_monitor_t *monitor);
-static ipp_t		*new_request(ipp_op_t op, int version, const char *uri,
-			             const char *user, const char *title,
-				     int num_options, cups_option_t *options,
-				     const char *compression, int copies,
-				     const char *format, _ppd_cache_t *pc,
-				     ipp_attribute_t *media_col_sup,
-				     ipp_attribute_t *doc_handling_sup);
-static const char	*password_cb(const char *);
-static void		report_attr(ipp_attribute_t *attr);
-static void		report_printer_state(ipp_t *ipp);
-#if defined(HAVE_GSSAPI) && defined(HAVE_XPC)
-static int		run_as_user(int argc, char *argv[], uid_t uid,
-			            const char *device_uri, int fd);
-#endif /* HAVE_GSSAPI && HAVE_XPC */
-static void		sigterm_handler(int sig);
-static int		timeout_cb(http_t *http, void *user_data);
-static void		update_reasons(ipp_attribute_t *attr, const char *s);
+static const char *password_cb(const char *);
+static void	report_attr(ipp_attribute_t *attr);
+static int	report_printer_state(ipp_t *ipp, int job_id);
 
+#ifdef __APPLE__
+static int	run_pictwps_filter(char **argv, const char *filename);
+#endif /* __APPLE__ */
+static void	sigterm_handler(int sig);
 
+
 /*
  * 'main()' - Send a file to the printer or server.
  *
@@ -193,60 +102,65 @@
 		*name,			/* Name of option */
 		*value,			/* Value of option */
 		sep;			/* Separator character */
-  http_addrlist_t *addrlist;		/* Address of printer */
   int		snmp_fd,		/* SNMP socket */
 		start_count,		/* Page count via SNMP at start */
 		page_count,		/* Page count via SNMP */
 		have_supplies;		/* Printer supports supply levels? */
   int		num_files;		/* Number of files to print */
   char		**files,		/* Files to print */
-		*compatfile = NULL;	/* Compatibility filename */
-  off_t		compatsize = 0;		/* Size of compatibility file */
+		*filename;		/* Pointer to single filename */
   int		port;			/* Port number (not used) */
-  char		portname[255];		/* Port name */
   char		uri[HTTP_MAX_URI];	/* Updated URI without user/pass */
-  http_status_t	http_status;		/* Status of HTTP request */
   ipp_status_t	ipp_status;		/* Status of IPP request */
   http_t	*http;			/* HTTP connection */
   ipp_t		*request,		/* IPP request */
 		*response,		/* IPP response */
 		*supported;		/* get-printer-attributes response */
   time_t	start_time;		/* Time of first connect */
+  int		recoverable;		/* Recoverable error shown? */
   int		contimeout;		/* Connection timeout */
-  int		delay,			/* Delay for retries */
-		prev_delay;		/* Previous delay */
-  const char	*compression;		/* Compression mode */
-  int		waitjob,		/* Wait for job complete? */
+  int		delay;			/* Delay for retries... */
+  int		compression,		/* Do compression of the job data? */
+		waitjob,		/* Wait for job complete? */
 		waitprinter;		/* Wait for printer ready? */
-  _cups_monitor_t monitor;		/* Monitoring data */
   ipp_attribute_t *job_id_attr;		/* job-id attribute */
   int		job_id;			/* job-id value */
   ipp_attribute_t *job_sheets;		/* job-media-sheets-completed */
   ipp_attribute_t *job_state;		/* job-state */
   ipp_attribute_t *copies_sup;		/* copies-supported */
-  ipp_attribute_t *cups_version;	/* cups-version */
   ipp_attribute_t *format_sup;		/* document-format-supported */
-  ipp_attribute_t *media_col_sup;	/* media-col-supported */
-  ipp_attribute_t *operations_sup;	/* operations-supported */
-  ipp_attribute_t *doc_handling_sup;	/* multiple-document-handling-supported */
   ipp_attribute_t *printer_state;	/* printer-state attribute */
   ipp_attribute_t *printer_accepting;	/* printer-is-accepting-jobs */
-  int		validate_job;		/* Does printer support Validate-Job? */
   int		copies,			/* Number of copies for job */
 		copies_remaining;	/* Number of copies remaining */
   const char	*content_type,		/* CONTENT_TYPE environment variable */
-		*final_content_type,	/* FINAL_CONTENT_TYPE environment var */
-		*document_format;	/* document-format value */
-  int		fd;			/* File descriptor */
-  off_t		bytes = 0;		/* Bytes copied */
-  char		buffer[16384];		/* Copy buffer */
+		*final_content_type;	/* FINAL_CONTENT_TYPE environment var */
 #if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
   struct sigaction action;		/* Actions for POSIX signals */
 #endif /* HAVE_SIGACTION && !HAVE_SIGSET */
   int		version;		/* IPP version */
-  ppd_file_t	*ppd;			/* PPD file */
-  _ppd_cache_t	*pc;			/* PPD cache and mapping data */
-  fd_set	input;			/* Input set for select() */
+  static const char * const pattrs[] =
+		{			/* Printer attributes we want */
+                  "com.apple.print.recoverable-message",
+		  "copies-supported",
+		  "document-format-supported",
+		  "marker-colors",
+		  "marker-high-levels",
+		  "marker-levels",
+		  "marker-low-levels",
+		  "marker-message",
+		  "marker-names",
+		  "marker-types",
+		  "printer-is-accepting-jobs",
+		  "printer-state",
+		  "printer-state-message",
+		  "printer-state-reasons",
+		};
+  static const char * const jattrs[] =
+		{			/* Job attributes we want */
+		  "job-media-sheets-completed",
+		  "job-state"
+		};
 
 
  /*
@@ -297,75 +211,12 @@
   else if (argc < 6)
   {
     _cupsLangPrintf(stderr,
-                    _("Usage: %s job-id user title copies options [file]"),
+                    _("Usage: %s job-id user title copies options [file]\n"),
 		    argv[0]);
     return (CUPS_BACKEND_STOP);
   }
 
  /*
-  * Get the device URI...
-  */
-
-  while ((device_uri = cupsBackendDeviceURI(argv)) == NULL)
-  {
-    _cupsLangPrintFilter(stderr, "INFO", _("Unable to locate printer."));
-    sleep(10);
-
-    if (getenv("CLASS") != NULL)
-      return (CUPS_BACKEND_FAILED);
-  }
-
-  if ((auth_info_required = getenv("AUTH_INFO_REQUIRED")) == NULL)
-    auth_info_required = "none";
-
-  state_reasons = _cupsArrayNewStrings(getenv("PRINTER_STATE_REASONS"));
-
-#ifdef HAVE_GSSAPI
- /*
-  * For Kerberos, become the printing user (if we can) to get the credentials
-  * that way.
-  */
-
-  if (!getuid() && (value = getenv("AUTH_UID")) != NULL)
-  {
-    uid_t	uid = (uid_t)atoi(value);
-					/* User ID */
-
-#  ifdef HAVE_XPC
-    if (uid > 0)
-    {
-      if (argc == 6)
-        return (run_as_user(argc, argv, uid, device_uri, 0));
-      else
-      {
-        int status = 0;			/* Exit status */
-
-        for (i = 6; i < argc && !status && !job_canceled; i ++)
-	{
-	  if ((fd = open(argv[i], O_RDONLY)) >= 0)
-	  {
-	    status = run_as_user(argc, argv, uid, device_uri, fd);
-	    close(fd);
-	  }
-	  else
-	  {
-	    _cupsLangPrintError("ERROR", _("Unable to open print file"));
-	    status = CUPS_BACKEND_FAILED;
-	  }
-	}
-
-	return (status);
-      }
-    }
-
-#  else /* No XPC, just try to run as the user ID */
-    if (uid > 0)
-      seteuid(uid);
-#  endif /* HAVE_XPC */
-  }
-#endif /* HAVE_GSSAPI */
-
- /*
   * Get the (final) content type...
   */
 
@@ -384,6 +235,9 @@
   * Extract the hostname and printer name from the URI...
   */
 
+  if ((device_uri = cupsBackendDeviceURI(argv)) == NULL)
+    return (CUPS_BACKEND_FAILED);
+
   httpSeparateURI(HTTP_URI_CODING_ALL, device_uri, scheme, sizeof(scheme),
                   username, sizeof(username), hostname, sizeof(hostname), &port,
 		  resource, sizeof(resource));
@@ -400,8 +254,8 @@
   * See if there are any options...
   */
 
-  compression = NULL;
-  version     = 20;
+  compression = 0;
+  version     = 11;
   waitjob     = 1;
   waitprinter = 1;
   contimeout  = 7 * 24 * 60 * 60;
@@ -454,48 +308,48 @@
       * Process the option...
       */
 
-      if (!_cups_strcasecmp(name, "waitjob"))
+      if (!strcasecmp(name, "waitjob"))
       {
        /*
         * Wait for job completion?
 	*/
 
-        waitjob = !_cups_strcasecmp(value, "on") ||
-	          !_cups_strcasecmp(value, "yes") ||
-	          !_cups_strcasecmp(value, "true");
+        waitjob = !strcasecmp(value, "on") ||
+	          !strcasecmp(value, "yes") ||
+	          !strcasecmp(value, "true");
       }
-      else if (!_cups_strcasecmp(name, "waitprinter"))
+      else if (!strcasecmp(name, "waitprinter"))
       {
        /*
         * Wait for printer idle?
 	*/
 
-        waitprinter = !_cups_strcasecmp(value, "on") ||
-	              !_cups_strcasecmp(value, "yes") ||
-	              !_cups_strcasecmp(value, "true");
+        waitprinter = !strcasecmp(value, "on") ||
+	              !strcasecmp(value, "yes") ||
+	              !strcasecmp(value, "true");
       }
-      else if (!_cups_strcasecmp(name, "encryption"))
+      else if (!strcasecmp(name, "encryption"))
       {
        /*
         * Enable/disable encryption?
 	*/
 
-        if (!_cups_strcasecmp(value, "always"))
+        if (!strcasecmp(value, "always"))
 	  cupsSetEncryption(HTTP_ENCRYPT_ALWAYS);
-        else if (!_cups_strcasecmp(value, "required"))
+        else if (!strcasecmp(value, "required"))
 	  cupsSetEncryption(HTTP_ENCRYPT_REQUIRED);
-        else if (!_cups_strcasecmp(value, "never"))
+        else if (!strcasecmp(value, "never"))
 	  cupsSetEncryption(HTTP_ENCRYPT_NEVER);
-        else if (!_cups_strcasecmp(value, "ifrequested"))
+        else if (!strcasecmp(value, "ifrequested"))
 	  cupsSetEncryption(HTTP_ENCRYPT_IF_REQUESTED);
 	else
 	{
-	  _cupsLangPrintFilter(stderr, "ERROR",
-			       _("Unknown encryption option value: \"%s\"."),
-			       value);
+	  _cupsLangPrintf(stderr,
+	                  _("ERROR: Unknown encryption option value \"%s\"!\n"),
+	        	  value);
         }
       }
-      else if (!_cups_strcasecmp(name, "version"))
+      else if (!strcasecmp(name, "version"))
       {
         if (!strcmp(value, "1.0"))
 	  version = 10;
@@ -505,24 +359,23 @@
 	  version = 20;
 	else if (!strcmp(value, "2.1"))
 	  version = 21;
-	else if (!strcmp(value, "2.2"))
-	  version = 22;
 	else
 	{
-	  _cupsLangPrintFilter(stderr, "ERROR",
-			       _("Unknown version option value: \"%s\"."),
-			       value);
+	  _cupsLangPrintf(stderr,
+	                  _("ERROR: Unknown version option value \"%s\"!\n"),
+	        	  value);
 	}
       }
 #ifdef HAVE_LIBZ
-      else if (!_cups_strcasecmp(name, "compression"))
+      else if (!strcasecmp(name, "compression"))
       {
-        if (!_cups_strcasecmp(value, "true") || !_cups_strcasecmp(value, "yes") ||
-	    !_cups_strcasecmp(value, "on") || !_cups_strcasecmp(value, "gzip"))
-	  compression = "gzip";
+        compression = !strcasecmp(value, "true") ||
+	              !strcasecmp(value, "yes") ||
+	              !strcasecmp(value, "on") ||
+	              !strcasecmp(value, "gzip");
       }
 #endif /* HAVE_LIBZ */
-      else if (!_cups_strcasecmp(name, "contimeout"))
+      else if (!strcasecmp(name, "contimeout"))
       {
        /*
         * Set the connection timeout...
@@ -537,9 +390,9 @@
         * Unknown option...
 	*/
 
-	_cupsLangPrintFilter(stderr, "ERROR",
-	                     _("Unknown option \"%s\" with value \"%s\"."),
-			     name, value);
+	_cupsLangPrintf(stderr,
+	                _("ERROR: Unknown option \"%s\" with value \"%s\"!\n"),
+			name, value);
       }
     }
   }
@@ -552,13 +405,64 @@
 
   if (argc == 6)
   {
-    num_files    = 0;
-    files        = NULL;
-    send_options = !_cups_strcasecmp(final_content_type, "application/pdf") ||
-                   !_cups_strcasecmp(final_content_type, "application/vnd.cups-pdf") ||
-                   !_cups_strncasecmp(final_content_type, "image/", 6);
+   /*
+    * Copy stdin to a temporary file...
+    */
 
-    fputs("DEBUG: Sending stdin for job...\n", stderr);
+    int			fd;		/* File descriptor */
+    http_addrlist_t	*addrlist;	/* Address list */
+    off_t		tbytes;		/* Total bytes copied */
+
+
+    fputs("STATE: +connecting-to-device\n", stderr);
+    fprintf(stderr, "DEBUG: Looking up \"%s\"...\n", hostname);
+
+    if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, "1")) == NULL)
+    {
+      _cupsLangPrintf(stderr, _("ERROR: Unable to locate printer \'%s\'!\n"),
+		      hostname);
+      return (CUPS_BACKEND_STOP);
+    }
+
+    snmp_fd = _cupsSNMPOpen(addrlist->addr.addr.sa_family);
+
+    if ((fd = cupsTempFd(tmpfilename, sizeof(tmpfilename))) < 0)
+    {
+      _cupsLangPrintError(_("ERROR: Unable to create temporary file"));
+      return (CUPS_BACKEND_FAILED);
+    }
+
+    _cupsLangPuts(stderr, _("INFO: Copying print data...\n"));
+
+    tbytes = backendRunLoop(-1, fd, snmp_fd, &(addrlist->addr), 0, 0,
+                            backendNetworkSideCB);
+
+    if (snmp_fd >= 0)
+      _cupsSNMPClose(snmp_fd);
+
+    httpAddrFreeList(addrlist);
+
+    close(fd);
+
+   /*
+    * Don't try printing files less than 2 bytes...
+    */
+
+    if (tbytes <= 1)
+    {
+      _cupsLangPuts(stderr, _("ERROR: Empty print file!\n"));
+      unlink(tmpfilename);
+      return (CUPS_BACKEND_FAILED);
+    }
+
+   /*
+    * Point to the single file from stdin...
+    */
+
+    filename     = tmpfilename;
+    num_files    = 1;
+    files        = &filename;
+    send_options = 0;
   }
   else
   {
@@ -574,10 +478,10 @@
     if (compression)
       compress_files(num_files, files);
 #endif /* HAVE_LIBZ */
-
-    fprintf(stderr, "DEBUG: %d files to send in job...\n", num_files);
   }
 
+  fprintf(stderr, "DEBUG: %d files to send in job...\n", num_files);
+
  /*
   * Set the authentication info, if any...
   */
@@ -595,7 +499,7 @@
 
     cupsSetUser(username);
   }
-  else
+  else if (!getuid())
   {
    /*
     * Try loading authentication information from the environment.
@@ -610,75 +514,23 @@
   }
 
  /*
-  * Try finding the remote server...
+  * Try connecting to the remote server...
   */
 
-  start_time = time(NULL);
+  delay       = 5;
+  recoverable = 0;
+  start_time  = time(NULL);
 
-  sprintf(portname, "%d", port);
+  fputs("STATE: +connecting-to-device\n", stderr);
 
-  update_reasons(NULL, "+connecting-to-device");
-  fprintf(stderr, "DEBUG: Looking up \"%s\"...\n", hostname);
-
-  while ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, portname)) == NULL)
-  {
-    _cupsLangPrintFilter(stderr, "INFO",
-                         _("Unable to locate printer \"%s\"."), hostname);
-    sleep(10);
-
-    if (getenv("CLASS") != NULL)
-    {
-      update_reasons(NULL, "-connecting-to-device");
-      return (CUPS_BACKEND_STOP);
-    }
-  }
-
-  http = _httpCreate(hostname, port, addrlist, cupsEncryption(), AF_UNSPEC);
-  httpSetTimeout(http, 30.0, timeout_cb, NULL);
-
- /*
-  * See if the printer supports SNMP...
-  */
-
-  if ((snmp_fd = _cupsSNMPOpen(addrlist->addr.addr.sa_family)) >= 0)
-  {
-    have_supplies = !backendSNMPSupplies(snmp_fd, &(addrlist->addr),
-                                         &start_count, NULL);
-  }
-  else
-    have_supplies = start_count = 0;
-
- /*
-  * Wait for data from the filter...
-  */
-
-  if (num_files == 0)
-  {
-    if (!backendWaitLoop(snmp_fd, &(addrlist->addr), 0, backendNetworkSideCB))
-      return (CUPS_BACKEND_OK);
-    else if ((bytes = read(0, buffer, sizeof(buffer))) <= 0)
-      return (CUPS_BACKEND_OK);
-  }
-
- /*
-  * Try connecting to the remote server...
-  */
-
-  delay = _cupsNextDelay(0, &prev_delay);
-
   do
   {
     fprintf(stderr, "DEBUG: Connecting to %s:%d\n", hostname, port);
-    _cupsLangPrintFilter(stderr, "INFO", _("Connecting to printer."));
+    _cupsLangPuts(stderr, _("INFO: Connecting to printer...\n"));
 
-    if (httpReconnect(http))
+    if ((http = httpConnectEncrypt(hostname, port, cupsEncryption())) == NULL)
     {
-      int error = errno;		/* Connection error */
-
-      if (http->status == HTTP_PKI_ERROR)
-	update_reasons(NULL, "+cups-certificate-error");
-
-      if (job_canceled)
+      if (job_cancelled)
 	break;
 
       if (getenv("CLASS") != NULL)
@@ -690,85 +542,100 @@
 	* available printer in the class.
 	*/
 
-        _cupsLangPrintFilter(stderr, "INFO",
-			     _("Unable to contact printer, queuing on next "
-			       "printer in class."));
+        _cupsLangPuts(stderr,
+	              _("INFO: Unable to contact printer, queuing on next "
+			"printer in class...\n"));
 
+        if (tmpfilename[0])
+	  unlink(tmpfilename);
+
        /*
         * Sleep 5 seconds to keep the job from requeuing too rapidly...
 	*/
 
 	sleep(5);
 
-	update_reasons(NULL, "-connecting-to-device");
-
         return (CUPS_BACKEND_FAILED);
       }
 
-      fprintf(stderr, "DEBUG: Connection error: %s\n", strerror(errno));
-
       if (errno == ECONNREFUSED || errno == EHOSTDOWN ||
           errno == EHOSTUNREACH)
       {
         if (contimeout && (time(NULL) - start_time) > contimeout)
 	{
-	  _cupsLangPrintFilter(stderr, "ERROR",
-	                       _("The printer is not responding."));
-	  update_reasons(NULL, "-connecting-to-device");
+	  _cupsLangPuts(stderr, _("ERROR: Printer not responding!\n"));
 	  return (CUPS_BACKEND_FAILED);
 	}
 
-	switch (error)
-	{
-	  case EHOSTDOWN :
-	      _cupsLangPrintFilter(stderr, "WARNING",
-			           _("The printer may not exist or "
-				     "is unavailable at this time."));
-	      break;
+        recoverable = 1;
 
-	  case EHOSTUNREACH :
-	      _cupsLangPrintFilter(stderr, "WARNING",
-				   _("The printer is unreachable at this "
-				     "time."));
-	      break;
+	_cupsLangPrintf(stderr,
+			_("WARNING: recoverable: Network host \'%s\' is busy; "
+			  "will retry in %d seconds...\n"),
+			hostname, delay);
 
-	  case ECONNREFUSED :
-	  default :
-	      _cupsLangPrintFilter(stderr, "WARNING",
-	                           _("The printer is busy."));
-	      break;
-        }
-
 	sleep(delay);
 
-        delay = _cupsNextDelay(delay, &prev_delay);
+	if (delay < 30)
+	  delay += 5;
       }
+      else if (h_errno)
+      {
+	_cupsLangPrintf(stderr, _("ERROR: Unable to locate printer \'%s\'!\n"),
+			hostname);
+	return (CUPS_BACKEND_STOP);
+      }
       else
       {
-	_cupsLangPrintFilter(stderr, "ERROR",
-	                     _("The printer is not responding."));
+        recoverable = 1;
+
+        fprintf(stderr, "DEBUG: Connection error: %s\n", strerror(errno));
+	_cupsLangPuts(stderr,
+	              _("ERROR: recoverable: Unable to connect to printer; will "
+			"retry in 30 seconds...\n"));
 	sleep(30);
       }
 
-      if (job_canceled)
+      if (job_cancelled)
 	break;
     }
-    else
-      update_reasons(NULL, "-cups-certificate-error");
   }
-  while (http->fd < 0);
+  while (http == NULL);
 
-  if (job_canceled || !http)
+  if (job_cancelled || !http)
+  {
+    if (tmpfilename[0])
+      unlink(tmpfilename);
+
     return (CUPS_BACKEND_FAILED);
+  }
 
-  update_reasons(NULL, "-connecting-to-device");
-  _cupsLangPrintFilter(stderr, "INFO", _("Connected to printer."));
+  fputs("STATE: -connecting-to-device\n", stderr);
+  _cupsLangPuts(stderr, _("INFO: Connected to printer...\n"));
 
-  fprintf(stderr, "DEBUG: Connected to %s:%d...\n",
-	  httpAddrString(http->hostaddr, addrname, sizeof(addrname)),
-	  _httpAddrPort(http->hostaddr));
+#ifdef AF_INET6
+  if (http->hostaddr->addr.sa_family == AF_INET6)
+    fprintf(stderr, "DEBUG: Connected to [%s]:%d (IPv6)...\n",
+	    httpAddrString(http->hostaddr, addrname, sizeof(addrname)),
+	    ntohs(http->hostaddr->ipv6.sin6_port));
+  else
+#endif /* AF_INET6 */
+    if (http->hostaddr->addr.sa_family == AF_INET)
+      fprintf(stderr, "DEBUG: Connected to %s:%d (IPv4)...\n",
+	      httpAddrString(http->hostaddr, addrname, sizeof(addrname)),
+	      ntohs(http->hostaddr->ipv4.sin_port));
 
  /*
+  * See if the printer supports SNMP...
+  */
+
+  if ((snmp_fd = _cupsSNMPOpen(http->hostaddr->addr.sa_family)) >= 0)
+    have_supplies = !backendSNMPSupplies(snmp_fd, http->hostaddr, &start_count,
+                                         NULL);
+  else
+    have_supplies = start_count = 0;
+
+ /*
   * Build a URI for the printer and fill the standard IPP attributes for
   * an IPP_PRINT_FILE request.  We can't use the URI in argv[0] because it
   * might contain username:password information...
@@ -779,17 +646,13 @@
 
  /*
   * First validate the destination and see if the device supports multiple
-  * copies...
+  * copies.  We have to do this because some IPP servers (e.g. HP JetDirect)
+  * don't support the copies attribute...
   */
 
-  copies_sup       = NULL;
-  cups_version     = NULL;
-  format_sup       = NULL;
-  media_col_sup    = NULL;
-  supported        = NULL;
-  operations_sup   = NULL;
-  doc_handling_sup = NULL;
-  validate_job     = 0;
+  copies_sup = NULL;
+  format_sup = NULL;
+  supported  = NULL;
 
   do
   {
@@ -821,73 +684,57 @@
     fputs("DEBUG: Getting supported attributes...\n", stderr);
 
     if (http->version < HTTP_1_1)
-    {
-      fprintf(stderr, "DEBUG: Printer responded with HTTP version %d.%d.\n",
-              http->version / 100, http->version % 100);
-      update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			   "cups-ipp-wrong-http-version");
-    }
+      httpReconnect(http);
 
-    supported  = cupsDoRequest(http, request, resource);
-    ipp_status = cupsLastError();
+    if ((supported = cupsDoRequest(http, request, resource)) == NULL)
+      ipp_status = cupsLastError();
+    else
+      ipp_status = supported->request.status.status_code;
 
-    fprintf(stderr, "DEBUG: Get-Printer-Attributes: %s (%s)\n",
-            ippErrorString(ipp_status), cupsLastErrorString());
-
     if (ipp_status > IPP_OK_CONFLICT)
     {
-      fprintf(stderr, "DEBUG: Get-Printer-Attributes returned %s.\n",
-              ippErrorString(ipp_status));
-
       if (ipp_status == IPP_PRINTER_BUSY ||
 	  ipp_status == IPP_SERVICE_UNAVAILABLE)
       {
         if (contimeout && (time(NULL) - start_time) > contimeout)
 	{
-	  _cupsLangPrintFilter(stderr, "ERROR",
-	                       _("The printer is not responding."));
+	  _cupsLangPuts(stderr, _("ERROR: Printer not responding!\n"));
 	  return (CUPS_BACKEND_FAILED);
 	}
 
-	_cupsLangPrintFilter(stderr, "INFO", _("The printer is busy."));
+        recoverable = 1;
 
-        report_printer_state(supported);
+	_cupsLangPrintf(stderr,
+			_("WARNING: recoverable: Network host \'%s\' is busy; "
+			  "will retry in %d seconds...\n"),
+			hostname, delay);
 
+        report_printer_state(supported, 0);
+
 	sleep(delay);
 
-        delay = _cupsNextDelay(delay, &prev_delay);
+	if (delay < 30)
+	  delay += 5;
       }
       else if ((ipp_status == IPP_BAD_REQUEST ||
 	        ipp_status == IPP_VERSION_NOT_SUPPORTED) && version > 10)
       {
        /*
-	* Switch to IPP/1.1 or IPP/1.0...
+	* Switch to IPP/1.0...
 	*/
 
-        if (version >= 20)
-	{
-	  _cupsLangPrintFilter(stderr, "INFO",
-			       _("Printer does not support IPP/%d.%d, trying "
-			         "IPP/%s."), version / 10, version % 10, "1.1");
-	  version = 11;
-	}
-	else
-	{
-	  _cupsLangPrintFilter(stderr, "INFO",
-			       _("Printer does not support IPP/%d.%d, trying "
-			         "IPP/%s."), version / 10, version % 10, "1.0");
-	  version = 10;
-        }
-
+	_cupsLangPrintf(stderr,
+	                _("INFO: Printer does not support IPP/%d.%d, trying "
+		          "IPP/1.0...\n"), version / 10, version % 10);
+	version = 10;
 	httpReconnect(http);
       }
       else if (ipp_status == IPP_NOT_FOUND)
       {
-        _cupsLangPrintFilter(stderr, "ERROR",
-			     _("The printer URI is incorrect or no longer "
-		               "exists."));
+        _cupsLangPuts(stderr, _("ERROR: Destination printer does not exist!\n"));
 
-	ippDelete(supported);
+	if (supported)
+          ippDelete(supported);
 
 	return (CUPS_BACKEND_STOP);
       }
@@ -902,92 +749,33 @@
       }
       else
       {
-	_cupsLangPrintFilter(stderr, "ERROR",
-	                     _("Unable to get printer status."));
+	_cupsLangPrintf(stderr,
+	                _("ERROR: Unable to get printer status (%s)!\n"),
+			cupsLastErrorString());
         sleep(10);
       }
 
-      ippDelete(supported);
-      supported = NULL;
+      if (supported)
+        ippDelete(supported);
+
       continue;
     }
-
-    if (!getenv("CLASS"))
+    else if ((copies_sup = ippFindAttribute(supported, "copies-supported",
+	                                    IPP_TAG_RANGE)) != NULL)
     {
      /*
-      * Check printer-is-accepting-jobs = false and printer-state-reasons for the
-      * "spool-area-full" keyword...
-      */
-
-      int busy = 0;
-
-      if ((printer_accepting = ippFindAttribute(supported,
-						"printer-is-accepting-jobs",
-						IPP_TAG_BOOLEAN)) != NULL &&
-	  !printer_accepting->values[0].boolean)
-        busy = 1;
-      else if (!printer_accepting)
-        update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-printer-is-accepting-jobs");
-
-      if ((printer_state = ippFindAttribute(supported,
-					    "printer-state-reasons",
-					    IPP_TAG_KEYWORD)) != NULL && !busy)
-      {
-	for (i = 0; i < printer_state->num_values; i ++)
-	  if (!strcmp(printer_state->values[0].string.text,
-	              "spool-area-full") ||
-	      !strncmp(printer_state->values[0].string.text, "spool-area-full-",
-		       16))
-	  {
-	    busy = 1;
-	    break;
-	  }
-      }
-      else
-        update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-printer-state-reasons");
-
-      if (busy)
-      {
-	_cupsLangPrintFilter(stderr, "INFO", _("The printer is busy."));
-
-	report_printer_state(supported);
-
-	sleep(delay);
-
-	delay = _cupsNextDelay(delay, &prev_delay);
-
-	ippDelete(supported);
-	supported = NULL;
-	continue;
-      }
-    }
-
-   /*
-    * Check for supported attributes...
-    */
-
-    if ((copies_sup = ippFindAttribute(supported, "copies-supported",
-	                               IPP_TAG_RANGE)) != NULL)
-    {
-     /*
       * Has the "copies-supported" attribute - does it have an upper
       * bound > 1?
       */
 
-      fprintf(stderr, "DEBUG: copies-supported=%d-%d\n",
-	      copies_sup->values[0].range.lower,
-	      copies_sup->values[0].range.upper);
-
       if (copies_sup->values[0].range.upper <= 1)
 	copies_sup = NULL; /* No */
     }
 
-    cups_version = ippFindAttribute(supported, "cups-version", IPP_TAG_TEXT);
+    format_sup = ippFindAttribute(supported, "document-format-supported",
+	                          IPP_TAG_MIMETYPE);
 
-    if ((format_sup = ippFindAttribute(supported, "document-format-supported",
-	                               IPP_TAG_MIMETYPE)) != NULL)
+    if (format_sup)
     {
       fprintf(stderr, "DEBUG: document-format-supported (%d values)\n",
 	      format_sup->num_values);
@@ -996,71 +784,7 @@
 	        format_sup->values[i].string.text);
     }
 
-    if ((media_col_sup = ippFindAttribute(supported, "media-col-supported",
-	                                  IPP_TAG_KEYWORD)) != NULL)
-    {
-      fprintf(stderr, "DEBUG: media-col-supported (%d values)\n",
-	      media_col_sup->num_values);
-      for (i = 0; i < media_col_sup->num_values; i ++)
-	fprintf(stderr, "DEBUG: [%d] = \"%s\"\n", i,
-	        media_col_sup->values[i].string.text);
-    }
-
-    if ((operations_sup = ippFindAttribute(supported, "operations-supported",
-					   IPP_TAG_ENUM)) != NULL)
-    {
-      for (i = 0; i < operations_sup->num_values; i ++)
-        if (operations_sup->values[i].integer == IPP_PRINT_JOB)
-	  break;
-
-      if (i >= operations_sup->num_values)
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-print-job");
-
-      for (i = 0; i < operations_sup->num_values; i ++)
-        if (operations_sup->values[i].integer == IPP_CANCEL_JOB)
-	  break;
-
-      if (i >= operations_sup->num_values)
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-cancel-job");
-
-      for (i = 0; i < operations_sup->num_values; i ++)
-        if (operations_sup->values[i].integer == IPP_GET_JOB_ATTRIBUTES)
-	  break;
-
-      if (i >= operations_sup->num_values)
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-                             "cups-ipp-missing-get-job-attributes");
-
-      for (i = 0; i < operations_sup->num_values; i ++)
-        if (operations_sup->values[i].integer == IPP_GET_PRINTER_ATTRIBUTES)
-	  break;
-
-      if (i >= operations_sup->num_values)
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-get-printer-attributes");
-
-      for (i = 0; i < operations_sup->num_values; i ++)
-        if (operations_sup->values[i].integer == IPP_VALIDATE_JOB)
-	{
-	  validate_job = 1;
-	  break;
-	}
-
-      if (!validate_job)
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-                             "cups-ipp-missing-validate-job");
-    }
-    else
-      update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			   "cups-ipp-missing-operations-supported");
-
-    doc_handling_sup = ippFindAttribute(supported,
-					"multiple-document-handling-supported",
-					IPP_TAG_KEYWORD);
-
-    report_printer_state(supported);
+    report_printer_state(supported, 0);
   }
   while (ipp_status > IPP_OK_CONFLICT);
 
@@ -1089,13 +813,16 @@
       * available printer in the class.
       */
 
-      _cupsLangPrintFilter(stderr, "INFO",
-                           _("Unable to contact printer, queuing on next "
-		             "printer in class."));
+      _cupsLangPuts(stderr,
+                    _("INFO: Unable to contact printer, queuing on next "
+		      "printer in class...\n"));
 
       ippDelete(supported);
       httpClose(http);
 
+      if (tmpfilename[0])
+	unlink(tmpfilename);
+
      /*
       * Sleep 5 seconds to keep the job from requeuing too rapidly...
       */
@@ -1106,6 +833,18 @@
     }
   }
 
+  if (recoverable)
+  {
+   /*
+    * If we've shown a recoverable error make sure the printer proxies
+    * have a chance to see the recovered message. Not pretty but
+    * necessary for now...
+    */
+
+    fputs("INFO: recovered: \n", stderr);
+    sleep(5);
+  }
+
  /*
   * See if the printer supports multiple copies...
   */
@@ -1116,309 +855,210 @@
   {
     copies_remaining = 1;
 
-    if (argc < 7 && !send_options)
+    if (argc < 7)
       copies = 1;
   }
   else
     copies_remaining = copies;
 
  /*
-  * Prepare remaining printing options...
+  * Then issue the print-job request...
   */
 
-  options = NULL;
-  pc      = NULL;
+  job_id  = 0;
 
-  if (send_options)
+  while (copies_remaining > 0)
   {
-    num_options = cupsParseOptions(argv[5], 0, &options);
+   /*
+    * Check for side-channel requests...
+    */
 
-    if (!cups_version && media_col_sup)
-    {
-     /*
-      * Load the PPD file and generate PWG attribute mapping information...
-      */
+    backendCheckSideChannel(snmp_fd, http->hostaddr);
 
-      ppd = ppdOpenFile(getenv("PPD"));
-      pc  = _ppdCacheCreateWithPPD(ppd);
+   /*
+    * Build the IPP request...
+    */
 
-      ppdClose(ppd);
-    }
-  }
-  else
-    num_options = 0;
+    if (job_cancelled)
+      break;
 
-  document_format = NULL;
+    if (num_files > 1)
+      request = ippNewRequest(IPP_CREATE_JOB);
+    else
+      request = ippNewRequest(IPP_PRINT_JOB);
 
-  if (format_sup != NULL)
-  {
-    for (i = 0; i < format_sup->num_values; i ++)
-      if (!_cups_strcasecmp(final_content_type, format_sup->values[i].string.text))
-      {
-        document_format = final_content_type;
-	break;
-      }
+    request->request.op.version[0] = version / 10;
+    request->request.op.version[1] = version % 10;
 
-    if (!document_format)
-    {
-      for (i = 0; i < format_sup->num_values; i ++)
-	if (!_cups_strcasecmp("application/octet-stream",
-	                format_sup->values[i].string.text))
-	{
-	  document_format = "application/octet-stream";
-	  break;
-	}
-    }
-  }
+    ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
+        	 NULL, uri);
 
- /*
-  * If the printer does not support HTTP/1.1 (which IPP requires), copy stdin
-  * to a temporary file so that we can do a HTTP/1.0 submission...
-  *
-  * (I hate compatibility hacks!)
-  */
+    fprintf(stderr, "DEBUG: printer-uri = \"%s\"\n", uri);
 
-  if (http->version < HTTP_1_1 && num_files == 0)
-  {
-    if ((fd = cupsTempFd(tmpfilename, sizeof(tmpfilename))) < 0)
-    {
-      perror("DEBUG: Unable to create temporary file");
-      return (CUPS_BACKEND_FAILED);
-    }
+    if (argv[2][0])
+      ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
+                   "requesting-user-name", NULL, argv[2]);
 
-    _cupsLangPrintFilter(stderr, "INFO", _("Copying print data."));
+    fprintf(stderr, "DEBUG: requesting-user-name = \"%s\"\n", argv[2]);
 
-    compatsize = backendRunLoop(-1, fd, snmp_fd, &(addrlist->addr), 0, 0,
-		                backendNetworkSideCB);
+   /*
+    * Only add a "job-name" attribute if the remote server supports
+    * copy generation - some IPP implementations like HP's don't seem
+    * to like UTF-8 job names (STR #1837)...
+    */
 
-    close(fd);
+    if (argv[3][0] && copies_sup)
+      ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "job-name", NULL,
+        	   argv[3]);
 
-    compatfile = tmpfilename;
-    files      = &compatfile;
-    num_files  = 1;
-  }
-  else if (http->version < HTTP_1_1 && num_files == 1)
-  {
-    struct stat	fileinfo;		/* File information */
+    fprintf(stderr, "DEBUG: job-name = \"%s\"\n", argv[3]);
 
-    if (!stat(files[0], &fileinfo))
-      compatsize = fileinfo.st_size;
-  }
+#ifdef HAVE_LIBZ
+    if (compression)
+      ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
+                   "compression", NULL, "gzip");
+#endif /* HAVE_LIBZ */
 
- /*
-  * Start monitoring the printer in the background...
-  */
+   /*
+    * Handle options on the command-line...
+    */
 
-  monitor.uri           = uri;
-  monitor.hostname      = hostname;
-  monitor.user          = argv[2];
-  monitor.resource      = resource;
-  monitor.port          = port;
-  monitor.version       = version;
-  monitor.job_id        = 0;
-  monitor.encryption    = cupsEncryption();
-  monitor.job_state     = IPP_JOB_PENDING;
-  monitor.printer_state = IPP_PRINTER_IDLE;
+    options     = NULL;
+    num_options = cupsParseOptions(argv[5], 0, &options);
 
-  _cupsThreadCreate((_cups_thread_func_t)monitor_printer, &monitor);
+#ifdef __APPLE__
+    if (!strcasecmp(final_content_type, "application/pictwps") &&
+        num_files == 1)
+    {
+      if (format_sup != NULL)
+      {
+	for (i = 0; i < format_sup->num_values; i ++)
+	  if (!strcasecmp(final_content_type, format_sup->values[i].string.text))
+	    break;
+      }
 
- /*
-  * Validate access to the printer...
-  */
+      if (format_sup == NULL || i >= format_sup->num_values)
+      {
+       /*
+	* Remote doesn't support "application/pictwps" (i.e. it's not MacOS X)
+	* so convert the document to PostScript...
+	*/
 
-  while (!job_canceled && validate_job)
-  {
-    request = new_request(IPP_VALIDATE_JOB, version, uri, argv[2], argv[3],
-                          num_options, options, compression,
-			  copies_sup ? copies : 1, document_format, pc,
-			  media_col_sup, doc_handling_sup);
+	if (run_pictwps_filter(argv, files[0]))
+	{
+	  if (pstmpname[0])
+	    unlink(pstmpname);
 
-    ippDelete(cupsDoRequest(http, request, resource));
+	  if (tmpfilename[0])
+	    unlink(tmpfilename);
 
-    ipp_status = cupsLastError();
+	  return (CUPS_BACKEND_FAILED);
+        }
 
-    fprintf(stderr, "DEBUG: Validate-Job: %s (%s)\n",
-            ippErrorString(ipp_status), cupsLastErrorString());
+        files[0] = pstmpname;
 
-    if (job_canceled)
-      break;
+       /*
+	* Change the MIME type to application/postscript and change the
+	* number of copies to 1...
+	*/
 
-    if (ipp_status == IPP_SERVICE_UNAVAILABLE || ipp_status == IPP_PRINTER_BUSY)
-    {
-      _cupsLangPrintFilter(stderr, "INFO", _("The printer is busy."));
-      sleep(10);
+	final_content_type = "application/postscript";
+	copies             = 1;
+	copies_remaining   = 1;
+        send_options       = 0;
+      }
     }
-    else if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN ||
-	     ipp_status == IPP_AUTHENTICATION_CANCELED)
+#endif /* __APPLE__ */
+
+    if (format_sup != NULL)
     {
-     /*
-      * Update auth-info-required as needed...
-      */
+      for (i = 0; i < format_sup->num_values; i ++)
+        if (!strcasecmp(final_content_type, format_sup->values[i].string.text))
+          break;
 
-      fprintf(stderr, "DEBUG: WWW-Authenticate=\"%s\"\n",
-	      httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE));
+      if (i < format_sup->num_values)
+        ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_MIMETYPE,
+	             "document-format", NULL, final_content_type);
+    }
 
+    if (copies_sup && version > 10 && send_options)
+    {
      /*
-      * Normal authentication goes through the password callback, which sets
-      * auth_info_required to "username,password".  Kerberos goes directly
-      * through GSSAPI, so look for Negotiate in the WWW-Authenticate header
-      * here and set auth_info_required as needed...
+      * Only send options if the destination printer supports the copies
+      * attribute and IPP/1.1.  This is a hack for the HP and Lexmark
+      * implementations of IPP, which do not accept extension attributes
+      * and incorrectly report a client-error-bad-request error instead of
+      * the successful-ok-unsupported-attributes status.  In short, at least
+      * some HP and Lexmark implementations of IPP are non-compliant.
       */
 
-      if (!strncmp(httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE),
-		   "Negotiate", 9))
-	auth_info_required = "negotiate";
+      cupsEncodeOptions(request, num_options, options);
 
-      goto cleanup;
+      ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_INTEGER, "copies",
+                    copies);
     }
-    else if (ipp_status == IPP_OPERATION_NOT_SUPPORTED)
-    {
-     /*
-      * This is all too common...
-      */
 
-      update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			   "cups-ipp-missing-validate-job");
-      break;
-    }
-    else if (ipp_status < IPP_REDIRECTION_OTHER_SITE)
-      break;
-  }
+    cupsFreeOptions(num_options, options);
 
- /*
-  * Then issue the print-job request...
-  */
-
-  job_id = 0;
-
-  while (!job_canceled && copies_remaining > 0)
-  {
    /*
-    * Check for side-channel requests...
+    * If copies aren't supported, then we are likely dealing with an HP
+    * JetDirect.  The HP IPP implementation seems to close the connection
+    * after every request - that is, it does *not* implement HTTP Keep-
+    * Alive, which is REQUIRED by HTTP/1.1...
     */
 
-    backendCheckSideChannel(snmp_fd, http->hostaddr);
+    if (!copies_sup)
+      httpReconnect(http);
 
    /*
-    * Build the IPP job creation request...
+    * Do the request...
     */
 
-    if (job_canceled)
-      break;
+    if (http->version < HTTP_1_1)
+      httpReconnect(http);
 
-    request = new_request(num_files > 1 ? IPP_CREATE_JOB : IPP_PRINT_JOB,
-			  version, uri, argv[2], argv[3], num_options, options,
-			  compression, copies_sup ? copies : 1, document_format,
-			  pc, media_col_sup, doc_handling_sup);
-
-   /*
-    * Do the request...
-    */
-
     if (num_files > 1)
       response = cupsDoRequest(http, request, resource);
     else
-    {
-      size_t	length = 0;		/* Length of request */
+      response = cupsDoFileRequest(http, request, resource, files[0]);
 
-      if (compatsize > 0)
-      {
-        fputs("DEBUG: Sending file using HTTP/1.0 Content-Length...\n", stderr);
-        length = ippLength(request) + (size_t)compatsize;
-      }
-      else
-        fputs("DEBUG: Sending file using HTTP/1.1 chunking...\n", stderr);
-
-      http_status = cupsSendRequest(http, request, resource, length);
-      if (http_status == HTTP_CONTINUE && request->state == IPP_DATA)
-      {
-        if (num_files == 1)
-	  fd = open(files[0], O_RDONLY);
-	else
-	{
-	  fd          = 0;
-	  http_status = cupsWriteRequestData(http, buffer, bytes);
-        }
-
-        while (http_status == HTTP_CONTINUE &&
-               (!job_canceled || compatsize > 0))
-	{
-	 /*
-	  * Check for side-channel requests and more print data...
-	  */
-
-          FD_ZERO(&input);
-	  FD_SET(fd, &input);
-	  FD_SET(snmp_fd, &input);
-
-          while (select(fd > snmp_fd ? fd + 1 : snmp_fd + 1, &input, NULL, NULL,
-	                NULL) <= 0 && !job_canceled);
-
-	  if (FD_ISSET(snmp_fd, &input))
-	    backendCheckSideChannel(snmp_fd, http->hostaddr);
-
-          if (FD_ISSET(fd, &input))
-          {
-            if ((bytes = read(fd, buffer, sizeof(buffer))) > 0)
-            {
-	      fprintf(stderr, "DEBUG: Read %d bytes...\n", (int)bytes);
-
-	      if (cupsWriteRequestData(http, buffer, bytes) != HTTP_CONTINUE)
-		break;
-	    }
-	    else if (bytes == 0 || (errno != EINTR && errno != EAGAIN))
-	      break;
-	  }
-	}
-
-        if (num_files == 1)
-	  close(fd);
-      }
-
-      response = cupsGetResponse(http, resource);
-      ippDelete(request);
-    }
-
     ipp_status = cupsLastError();
 
-    fprintf(stderr, "DEBUG: %s: %s (%s)\n",
-            num_files > 1 ? "Create-Job" : "Print-Job",
-            ippErrorString(ipp_status), cupsLastErrorString());
-
     if (ipp_status > IPP_OK_CONFLICT)
     {
       job_id = 0;
 
-      if (job_canceled)
+      if (job_cancelled)
         break;
 
       if (ipp_status == IPP_SERVICE_UNAVAILABLE ||
-          ipp_status == IPP_NOT_POSSIBLE ||
 	  ipp_status == IPP_PRINTER_BUSY)
       {
-	_cupsLangPrintFilter(stderr, "INFO", _("The printer is busy."));
+        _cupsLangPuts(stderr,
+	              _("INFO: Printer busy; will retry in 10 seconds...\n"));
 	sleep(10);
+      }
+      else if ((ipp_status == IPP_BAD_REQUEST ||
+	        ipp_status == IPP_VERSION_NOT_SUPPORTED) && version > 10)
+      {
+       /*
+	* Switch to IPP/1.0...
+	*/
 
-	if (num_files == 0)
-	{
-	 /*
-	  * We can't re-submit when we have no files to print, so exit
-	  * immediately with the right status code...
-	  */
-
-	  goto cleanup;
-	}
+	_cupsLangPrintf(stderr,
+	                _("INFO: Printer does not support IPP/%d.%d, trying "
+		          "IPP/1.0...\n"), version / 10, version % 10);
+	version = 10;
+	httpReconnect(http);
       }
-      else if (ipp_status == IPP_ERROR_JOB_CANCELED)
-        goto cleanup;
       else
       {
        /*
 	* Update auth-info-required as needed...
 	*/
 
-        _cupsLangPrintFilter(stderr, "ERROR",
-	                     _("Print file was not accepted."));
+        _cupsLangPrintf(stderr, _("ERROR: Print file was not accepted (%s)!\n"),
+			cupsLastErrorString());
 
 	if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN)
 	{
@@ -1436,39 +1076,25 @@
 		       "Negotiate", 9))
 	    auth_info_required = "negotiate";
 	}
-	else
-	  sleep(10);
-
-	if (num_files == 0)
-	{
-	 /*
-	  * We can't re-submit when we have no files to print, so exit
-	  * immediately with the right status code...
-	  */
-
-	  goto cleanup;
-	}
       }
     }
     else if ((job_id_attr = ippFindAttribute(response, "job-id",
                                              IPP_TAG_INTEGER)) == NULL)
     {
-      _cupsLangPrintFilter(stderr, "INFO",
-			   _("Print file accepted - job ID unknown."));
-      update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			   "cups-ipp-missing-job-id");
+      _cupsLangPuts(stderr,
+                    _("NOTICE: Print file accepted - job ID unknown.\n"));
       job_id = 0;
     }
     else
     {
-      monitor.job_id = job_id = job_id_attr->values[0].integer;
-      _cupsLangPrintFilter(stderr, "INFO",
-                           _("Print file accepted - job ID %d."), job_id);
+      job_id = job_id_attr->values[0].integer;
+      _cupsLangPrintf(stderr, _("NOTICE: Print file accepted - job ID %d.\n"),
+                      job_id);
     }
 
     ippDelete(response);
 
-    if (job_canceled)
+    if (job_cancelled)
       break;
 
     if (job_id && num_files > 1)
@@ -1505,41 +1131,18 @@
         ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_MIMETYPE,
 	             "document-format", NULL, content_type);
 
-	fprintf(stderr, "DEBUG: Sending file %d using chunking...\n", i + 1);
-	http_status = cupsSendRequest(http, request, resource, 0);
-	if (http_status == HTTP_CONTINUE && request->state == IPP_DATA &&
-	    (fd = open(files[i], O_RDONLY)) >= 0)
-	{
-	  while (!job_canceled &&
-	         (bytes = read(fd, buffer, sizeof(buffer))) > 0)
-	  {
-	    if (cupsWriteRequestData(http, buffer, bytes) != HTTP_CONTINUE)
-	      break;
-	    else
-	    {
-	     /*
-	      * Check for side-channel requests...
-	      */
+	if (http->version < HTTP_1_1)
+	  httpReconnect(http);
 
-	      backendCheckSideChannel(snmp_fd, http->hostaddr);
-	    }
-	  }
+        ippDelete(cupsDoFileRequest(http, request, resource, files[i]));
 
-	  close(fd);
-	}
-
-	ippDelete(cupsGetResponse(http, resource));
-	ippDelete(request);
-
-	fprintf(stderr, "DEBUG: Send-Document: %s (%s)\n",
-		ippErrorString(cupsLastError()), cupsLastErrorString());
-
 	if (cupsLastError() > IPP_OK_CONFLICT)
 	{
 	  ipp_status = cupsLastError();
 
-	  _cupsLangPrintFilter(stderr, "ERROR",
-			       _("Unable to add document to print job."));
+	  _cupsLangPrintf(stderr,
+			  _("ERROR: Unable to add file %d to job: %s\n"),
+			  job_id, cupsLastErrorString());
 	  break;
 	}
       }
@@ -1551,7 +1154,6 @@
       copies_remaining --;
     }
     else if (ipp_status == IPP_SERVICE_UNAVAILABLE ||
-             ipp_status == IPP_NOT_POSSIBLE ||
 	     ipp_status == IPP_PRINTER_BUSY)
       continue;
     else
@@ -1564,9 +1166,9 @@
     if (!job_id || !waitjob)
       continue;
 
-    _cupsLangPrintFilter(stderr, "INFO", _("Waiting for job to complete."));
+    _cupsLangPuts(stderr, _("INFO: Waiting for job to complete...\n"));
 
-    for (delay = _cupsNextDelay(0, &prev_delay); !job_canceled;)
+    for (delay = 1; !job_cancelled;)
     {
      /*
       * Check for side-channel requests...
@@ -1600,7 +1202,9 @@
       * Do the request...
       */
 
-      httpReconnect(http);
+      if (!copies_sup || http->version < HTTP_1_1)
+	httpReconnect(http);
+
       response   = cupsDoRequest(http, request, resource);
       ipp_status = cupsLastError();
 
@@ -1610,27 +1214,22 @@
         * Job has gone away and/or the server has no job history...
 	*/
 
-	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			     "cups-ipp-missing-job-history");
         ippDelete(response);
 
 	ipp_status = IPP_OK;
         break;
       }
 
-      fprintf(stderr, "DEBUG: Get-Job-Attributes: %s (%s)\n",
-	      ippErrorString(ipp_status), cupsLastErrorString());
-
       if (ipp_status > IPP_OK_CONFLICT)
       {
 	if (ipp_status != IPP_SERVICE_UNAVAILABLE &&
-	    ipp_status != IPP_NOT_POSSIBLE &&
 	    ipp_status != IPP_PRINTER_BUSY)
 	{
 	  ippDelete(response);
 
-          _cupsLangPrintFilter(stderr, "ERROR",
-			       _("Unable to get print job status."));
+          _cupsLangPrintf(stderr,
+			  _("ERROR: Unable to get job %d attributes (%s)!\n"),
+			  job_id, cupsLastErrorString());
           break;
 	}
       }
@@ -1640,41 +1239,23 @@
 	if ((job_state = ippFindAttribute(response, "job-state",
 	                                  IPP_TAG_ENUM)) != NULL)
 	{
-         /*
-	  * Reflect the remote job state in the local queue...
-	  */
-
-	  if (cups_version &&
-	      job_state->values[0].integer >= IPP_JOB_PENDING &&
-	      job_state->values[0].integer <= IPP_JOB_COMPLETED)
-	    update_reasons(NULL,
-	                   remote_job_states[job_state->values[0].integer -
-			                     IPP_JOB_PENDING]);
-
-	  if ((job_sheets = ippFindAttribute(response,
-					     "job-media-sheets-completed",
-					     IPP_TAG_INTEGER)) == NULL)
-	    job_sheets = ippFindAttribute(response,
-					  "job-impressions-completed",
-					  IPP_TAG_INTEGER);
-
-	  if (job_sheets)
-	    fprintf(stderr, "PAGE: total %d\n",
-		    job_sheets->values[0].integer);
-
 	 /*
           * Stop polling if the job is finished or pending-held...
 	  */
 
           if (job_state->values[0].integer > IPP_JOB_STOPPED)
 	  {
+	    if ((job_sheets = ippFindAttribute(response, 
+	                                       "job-media-sheets-completed",
+	                                       IPP_TAG_INTEGER)) != NULL)
+	      fprintf(stderr, "PAGE: total %d\n",
+	              job_sheets->values[0].integer);
+
 	    ippDelete(response);
 	    break;
 	  }
 	}
-	else if (ipp_status != IPP_SERVICE_UNAVAILABLE &&
-		 ipp_status != IPP_NOT_POSSIBLE &&
-		 ipp_status != IPP_PRINTER_BUSY)
+	else
 	{
 	 /*
 	  * If the printer does not return a job-state attribute, it does not
@@ -1682,8 +1263,8 @@
 	  * the job...
 	  */
 
-	  update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
-			       "cups-ipp-missing-job-state");
+          fputs("DEBUG: No job-state available from printer - stopping queue.\n",
+	        stderr);
 	  ipp_status = IPP_INTERNAL_ERROR;
 	  break;
 	}
@@ -1692,12 +1273,20 @@
       ippDelete(response);
 
      /*
-      * Wait before polling again...
+      * Check the printer state and report it if necessary...
       */
 
+      check_printer_state(http, uri, resource, argv[2], version, job_id);
+
+     /*
+      * Wait 1-10 seconds before polling again...
+      */
+
       sleep(delay);
 
-      delay = _cupsNextDelay(delay, &prev_delay);
+      delay ++;
+      if (delay > 10)
+        delay = 1;
     }
   }
 
@@ -1705,20 +1294,20 @@
   * Cancel the job as needed...
   */
 
-  if (job_canceled && job_id)
+  if (job_cancelled && job_id)
     cancel_job(http, uri, job_id, resource, argv[2], version);
 
  /*
   * Check the printer state and report it if necessary...
   */
 
-  check_printer_state(http, uri, resource, argv[2], version);
+  check_printer_state(http, uri, resource, argv[2], version, job_id);
 
  /*
   * Collect the final page count as needed...
   */
 
-  if (have_supplies &&
+  if (have_supplies && 
       !backendSNMPSupplies(snmp_fd, http->hostaddr, &page_count, NULL) &&
       page_count > start_count)
     fprintf(stderr, "PAGE: total %d\n", page_count - start_count);
@@ -1736,11 +1325,6 @@
   * Free memory...
   */
 
-  cleanup:
-
-  cupsFreeOptions(num_options, options);
-  _ppdCacheDestroy(pc);
-
   httpClose(http);
 
   ippDelete(supported);
@@ -1760,28 +1344,26 @@
   }
 #endif /* HAVE_LIBZ */
 
+#ifdef __APPLE__
+  if (pstmpname[0])
+    unlink(pstmpname);
+#endif /* __APPLE__ */
+
  /*
   * Return the queue status...
   */
 
-  if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN ||
-      ipp_status == IPP_AUTHENTICATION_CANCELED ||
-      ipp_status <= IPP_OK_CONFLICT)
-    fprintf(stderr, "ATTR: auth-info-required=%s\n", auth_info_required);
+  fprintf(stderr, "ATTR: auth-info-required=%s\n", auth_info_required);
 
-  if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN ||
-      ipp_status == IPP_AUTHENTICATION_CANCELED)
+  if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN)
     return (CUPS_BACKEND_AUTH_REQUIRED);
   else if (ipp_status == IPP_INTERNAL_ERROR)
     return (CUPS_BACKEND_STOP);
-  else if (ipp_status == IPP_DOCUMENT_FORMAT ||
-           ipp_status == IPP_CONFLICT)
+  else if (ipp_status > IPP_OK_CONFLICT)
     return (CUPS_BACKEND_FAILED);
-  else if (ipp_status > IPP_OK_CONFLICT && ipp_status != IPP_ERROR_JOB_CANCELED)
-    return (CUPS_BACKEND_RETRY_CURRENT);
   else
   {
-    _cupsLangPrintFilter(stderr, "INFO", _("Ready to print."));
+    _cupsLangPuts(stderr, _("INFO: Ready to print.\n"));
     return (CUPS_BACKEND_OK);
   }
 }
@@ -1802,7 +1384,7 @@
   ipp_t	*request;			/* Cancel-Job request */
 
 
-  _cupsLangPrintFilter(stderr, "INFO", _("Canceling print job."));
+  _cupsLangPuts(stderr, _("INFO: Canceling print job...\n"));
 
   request = ippNewRequest(IPP_CANCEL_JOB);
   request->request.op.version[0] = version / 10;
@@ -1820,34 +1402,47 @@
   * Do the request...
   */
 
+  if (http->version < HTTP_1_1)
+    httpReconnect(http);
+
   ippDelete(cupsDoRequest(http, request, resource));
 
   if (cupsLastError() > IPP_OK_CONFLICT)
-    _cupsLangPrintFilter(stderr, "ERROR", _("Unable to cancel print job."));
+    _cupsLangPrintf(stderr, _("ERROR: Unable to cancel job %d: %s\n"), id,
+		    cupsLastErrorString());
 }
 
 
 /*
- * 'check_printer_state()' - Check the printer state.
+ * 'check_printer_state()' - Check the printer state...
  */
 
-static ipp_pstate_t			/* O - Current printer-state */
+static void
 check_printer_state(
     http_t      *http,			/* I - HTTP connection */
     const char  *uri,			/* I - Printer URI */
     const char  *resource,		/* I - Resource path */
     const char  *user,			/* I - Username, if any */
-    int         version)		/* I - IPP version */
- {
-  ipp_t		*request,		/* IPP request */
-		*response;		/* IPP response */
-  ipp_attribute_t *attr;		/* Attribute in response */
-  ipp_pstate_t	printer_state = IPP_PRINTER_STOPPED;
-					/* Current printer-state */
+    int         version,		/* I - IPP version */
+    int         job_id)			/* I - Current job ID */
+{
+  ipp_t	*request,			/* IPP request */
+	*response;			/* IPP response */
+  static const char * const attrs[] =	/* Attributes we want */
+  {
+    "com.apple.print.recoverable-message",
+    "marker-colors",
+    "marker-levels",
+    "marker-message",
+    "marker-names",
+    "marker-types",
+    "printer-state-message",
+    "printer-state-reasons"
+  };
 
 
  /*
-  * Send a Get-Printer-Attributes request and log the results...
+  * Check on the printer state...
   */
 
   request = ippNewRequest(IPP_GET_PRINTER_ATTRIBUTES);
@@ -1855,41 +1450,34 @@
   request->request.op.version[1] = version % 10;
 
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
-	       NULL, uri);
+               NULL, uri);
 
   if (user && user[0])
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-		 "requesting-user-name", NULL, user);
+                 "requesting-user-name", NULL, user);
 
   ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-		"requested-attributes",
-		(int)(sizeof(pattrs) / sizeof(pattrs[0])), NULL, pattrs);
+                "requested-attributes",
+		(int)(sizeof(attrs) / sizeof(attrs[0])), NULL, attrs);
 
+ /*
+  * Do the request...
+  */
+
+  if (http->version < HTTP_1_1)
+    httpReconnect(http);
+
   if ((response = cupsDoRequest(http, request, resource)) != NULL)
   {
-    report_printer_state(response);
-
-    if ((attr = ippFindAttribute(response, "printer-state",
-				 IPP_TAG_ENUM)) != NULL)
-      printer_state = (ipp_pstate_t)attr->values[0].integer;
-
+    report_printer_state(response, job_id);
     ippDelete(response);
   }
-
-  fprintf(stderr, "DEBUG: Get-Printer-Attributes: %s (%s)\n",
-	  ippErrorString(cupsLastError()), cupsLastErrorString());
-
- /*
-  * Return the printer-state value...
-  */
-
-  return (printer_state);
 }
 
 
 #ifdef HAVE_LIBZ
 /*
- * 'compress_files()' - Compress print files.
+ * 'compress_files()' - Compress print files...
  */
 
 static void
@@ -1912,19 +1500,25 @@
   {
     if ((fd = cupsTempFd(filename, sizeof(filename))) < 0)
     {
-      _cupsLangPrintError("ERROR", _("Unable to create compressed print file"));
+      _cupsLangPrintf(stderr,
+		      _("ERROR: Unable to create temporary compressed print "
+		        "file: %s\n"), strerror(errno));
       exit(CUPS_BACKEND_FAILED);
     }
 
     if ((out = cupsFileOpenFd(fd, "w9")) == NULL)
     {
-      _cupsLangPrintError("ERROR", _("Unable to open compressed print file"));
+      _cupsLangPrintf(stderr,
+		      _("ERROR: Unable to open temporary compressed print "
+		        "file: %s\n"), strerror(errno));
       exit(CUPS_BACKEND_FAILED);
     }
 
     if ((in = cupsFileOpen(files[i], "r")) == NULL)
     {
-      _cupsLangPrintError("ERROR", _("Unable to open print file"));
+      _cupsLangPrintf(stderr,
+                      _("ERROR: Unable to open print file \"%s\": %s\n"),
+		      files[i], strerror(errno));
       cupsFileClose(out);
       exit(CUPS_BACKEND_FAILED);
     }
@@ -1933,8 +1527,9 @@
     while ((bytes = cupsFileRead(in, buffer, sizeof(buffer))) > 0)
       if (cupsFileWrite(out, buffer, bytes) < bytes)
       {
-	_cupsLangPrintError("ERROR",
-	                    _("Unable to generate compressed print file"));
+        _cupsLangPrintf(stderr,
+		        _("ERROR: Unable to write %d bytes to \"%s\": %s\n"),
+			(int)bytes, filename, strerror(errno));
         cupsFileClose(in);
         cupsFileClose(out);
 	exit(CUPS_BACKEND_FAILED);
@@ -1959,365 +1554,6 @@
 
 
 /*
- * 'monitor_printer()' - Monitor the printer state.
- */
-
-static void *				/* O - Thread exit code */
-monitor_printer(
-    _cups_monitor_t *monitor)		/* I - Monitoring data */
-{
-  http_t	*http;			/* Connection to printer */
-  ipp_t		*request,		/* IPP request */
-		*response;		/* IPP response */
-  ipp_attribute_t *attr;		/* Attribute in response */
-  int		delay,			/* Current delay */
-		prev_delay;		/* Previous delay */
-
-
- /*
-  * Make a copy of the printer connection...
-  */
-
-  http = _httpCreate(monitor->hostname, monitor->port, NULL, monitor->encryption,
-                     AF_UNSPEC);
-  httpSetTimeout(http, 30.0, timeout_cb, NULL);
-  cupsSetPasswordCB(password_cb);
-
- /*
-  * Loop until the job is canceled, aborted, or completed.
-  */
-
-  delay = _cupsNextDelay(0, &prev_delay);
-
-  while (monitor->job_state < IPP_JOB_CANCELED && !job_canceled)
-  {
-   /*
-    * Reconnect to the printer...
-    */
-
-    if (!httpReconnect(http))
-    {
-     /*
-      * Connected, so check on the printer state...
-      */
-
-      monitor->printer_state = check_printer_state(http, monitor->uri,
-                                                   monitor->resource,
-						   monitor->user,
-						   monitor->version);
-
-      if (monitor->job_id > 0)
-      {
-       /*
-        * Check the status of the job itself...
-	*/
-
-	request = ippNewRequest(IPP_GET_JOB_ATTRIBUTES);
-	request->request.op.version[0] = monitor->version / 10;
-	request->request.op.version[1] = monitor->version % 10;
-
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
-		     NULL, monitor->uri);
-	ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER, "job-id",
-	              monitor->job_id);
-
-	if (monitor->user && monitor->user[0])
-	  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-		       "requesting-user-name", NULL, monitor->user);
-
-	ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-		      "requested-attributes",
-		      (int)(sizeof(jattrs) / sizeof(jattrs[0])), NULL, jattrs);
-
-       /*
-	* Do the request...
-	*/
-
-	response = cupsDoRequest(http, request, monitor->resource);
-
-	fprintf(stderr, "DEBUG: Get-Job-Attributes: %s (%s)\n",
-		ippErrorString(cupsLastError()), cupsLastErrorString());
-
-	if ((attr = ippFindAttribute(response, "job-state",
-				     IPP_TAG_ENUM)) != NULL)
-	  monitor->job_state = (ipp_jstate_t)attr->values[0].integer;
-	else
-	  monitor->job_state = IPP_JOB_COMPLETED;
-
-	ippDelete(response);
-      }
-
-     /*
-      * Disconnect from the printer - we'll reconnect on the next poll...
-      */
-
-      _httpDisconnect(http);
-    }
-
-   /*
-    * Sleep for N seconds...
-    */
-
-    sleep(delay);
-
-    delay = _cupsNextDelay(delay, &prev_delay);
-  }
-
- /*
-  * Cleanup and return...
-  */
-
-  httpClose(http);
-
-  return (NULL);
-}
-
-
-/*
- * 'new_request()' - Create a new print creation or validation request.
- */
-
-static ipp_t *				/* O - Request data */
-new_request(
-    ipp_op_t        op,			/* I - IPP operation code */
-    int             version,		/* I - IPP version number */
-    const char      *uri,		/* I - printer-uri value */
-    const char      *user,		/* I - requesting-user-name value */
-    const char      *title,		/* I - job-name value */
-    int             num_options,	/* I - Number of options to send */
-    cups_option_t   *options,		/* I - Options to send */
-    const char      *compression,	/* I - compression value or NULL */
-    int             copies,		/* I - copies value or 0 */
-    const char      *format,		/* I - documet-format value or NULL */
-    _ppd_cache_t    *pc,		/* I - PPD cache and mapping data */
-    ipp_attribute_t *media_col_sup,	/* I - media-col-supported values */
-    ipp_attribute_t *doc_handling_sup)  /* I - multiple-document-handling-supported values */
-{
-  int		i;			/* Looping var */
-  ipp_t		*request;		/* Request data */
-  const char	*keyword;		/* PWG keyword */
-  _pwg_size_t	*size;			/* PWG media size */
-  ipp_t		*media_col,		/* media-col value */
-		*media_size;		/* media-size value */
-  const char	*media_source,		/* media-source value */
-		*media_type,		/* media-type value */
-		*collate_str;		/* multiple-document-handling value */
-
-
- /*
-  * Create the IPP request...
-  */
-
-  request                        = ippNewRequest(op);
-  request->request.op.version[0] = version / 10;
-  request->request.op.version[1] = version % 10;
-
-  fprintf(stderr, "DEBUG: %s IPP/%d.%d\n",
-	  ippOpString(request->request.op.operation_id),
-	  request->request.op.version[0],
-	  request->request.op.version[1]);
-
- /*
-  * Add standard attributes...
-  */
-
-  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
-	       NULL, uri);
-  fprintf(stderr, "DEBUG: printer-uri=\"%s\"\n", uri);
-
-  if (user && *user)
-  {
-    ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-		 "requesting-user-name", NULL, user);
-    fprintf(stderr, "DEBUG: requesting-user-name=\"%s\"\n", user);
-  }
-
-  if (title && *title)
-  {
-    ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "job-name", NULL,
-		 title);
-    fprintf(stderr, "DEBUG: job-name=\"%s\"\n", title);
-  }
-
-  if (format)
-  {
-    ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_MIMETYPE,
-		 "document-format", NULL, format);
-    fprintf(stderr, "DEBUG: document-format=\"%s\"\n", format);
-  }
-
-#ifdef HAVE_LIBZ
-  if (compression)
-  {
-    ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-		 "compression", NULL, compression);
-    fprintf(stderr, "DEBUG: compression=\"%s\"\n", compression);
-  }
-#endif /* HAVE_LIBZ */
-
- /*
-  * Handle options on the command-line...
-  */
-
-  if (num_options > 0)
-  {
-    if (pc)
-    {
-     /*
-      * Send standard IPP attributes...
-      */
-
-      if ((keyword = cupsGetOption("PageSize", num_options, options)) == NULL)
-	keyword = cupsGetOption("media", num_options, options);
-
-      if ((size = _ppdCacheGetSize(pc, keyword)) != NULL)
-      {
-       /*
-        * Add a media-col value...
-	*/
-
-	media_size = ippNew();
-	ippAddInteger(media_size, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-		      "x-dimension", size->width);
-	ippAddInteger(media_size, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-		      "y-dimension", size->length);
-
-	media_col = ippNew();
-	ippAddCollection(media_col, IPP_TAG_ZERO, "media-size", media_size);
-
-	media_source = _ppdCacheGetSource(pc, cupsGetOption("InputSlot",
-							    num_options,
-							    options));
-	media_type   = _ppdCacheGetType(pc, cupsGetOption("MediaType",
-						          num_options,
-							  options));
-
-	for (i = 0; i < media_col_sup->num_values; i ++)
-	{
-	  if (!strcmp(media_col_sup->values[i].string.text,
-		      "media-left-margin"))
-	    ippAddInteger(media_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-			  "media-left-margin", size->left);
-	  else if (!strcmp(media_col_sup->values[i].string.text,
-			   "media-bottom-margin"))
-	    ippAddInteger(media_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-			  "media-bottom-margin", size->bottom);
-	  else if (!strcmp(media_col_sup->values[i].string.text,
-			   "media-right-margin"))
-	    ippAddInteger(media_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-			  "media-right-margin", size->right);
-	  else if (!strcmp(media_col_sup->values[i].string.text,
-			   "media-top-margin"))
-	    ippAddInteger(media_col, IPP_TAG_ZERO, IPP_TAG_INTEGER,
-			  "media-top-margin", size->top);
-	  else if (!strcmp(media_col_sup->values[i].string.text,
-			   "media-source") && media_source)
-	    ippAddString(media_col, IPP_TAG_ZERO, IPP_TAG_KEYWORD,
-			 "media-source", NULL, media_source);
-	  else if (!strcmp(media_col_sup->values[i].string.text,
-			   "media-type") && media_type)
-	    ippAddString(media_col, IPP_TAG_ZERO, IPP_TAG_KEYWORD,
-			 "media-type", NULL, media_type);
-	}
-
-	ippAddCollection(request, IPP_TAG_JOB, "media-col", media_col);
-      }
-
-      if ((keyword = cupsGetOption("output-bin", num_options,
-				   options)) == NULL)
-	keyword = _ppdCacheGetBin(pc, cupsGetOption("OutputBin", num_options,
-						    options));
-
-      if (keyword)
-	ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "output-bin",
-		     NULL, keyword);
-
-      if ((keyword = cupsGetOption("output-mode", num_options,
-				   options)) != NULL)
-	ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "output-mode",
-		     NULL, keyword);
-      else if ((keyword = cupsGetOption("ColorModel", num_options,
-					options)) != NULL)
-      {
-	if (!_cups_strcasecmp(keyword, "Gray"))
-	  ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "output-mode",
-			       NULL, "monochrome");
-	else
-	  ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "output-mode",
-			   NULL, "color");
-      }
-
-      if ((keyword = cupsGetOption("print-quality", num_options,
-				   options)) != NULL)
-	ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_ENUM, "print-quality",
-		      atoi(keyword));
-      else if ((keyword = cupsGetOption("cupsPrintQuality", num_options,
-					options)) != NULL)
-      {
-	if (!_cups_strcasecmp(keyword, "draft"))
-	  ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_ENUM, "print-quality",
-			IPP_QUALITY_DRAFT);
-	else if (!_cups_strcasecmp(keyword, "normal"))
-	  ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_ENUM, "print-quality",
-			IPP_QUALITY_NORMAL);
-	else if (!_cups_strcasecmp(keyword, "high"))
-	  ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_ENUM, "print-quality",
-			IPP_QUALITY_HIGH);
-      }
-
-      if ((keyword = cupsGetOption("sides", num_options, options)) != NULL)
-	ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "sides",
-		     NULL, keyword);
-      else if (pc->sides_option &&
-               (keyword = cupsGetOption(pc->sides_option, num_options,
-					options)) != NULL)
-      {
-	if (!_cups_strcasecmp(keyword, pc->sides_1sided))
-	  ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "sides",
-		       NULL, "one-sided");
-	else if (!_cups_strcasecmp(keyword, pc->sides_2sided_long))
-	  ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "sides",
-		       NULL, "two-sided-long-edge");
-	if (!_cups_strcasecmp(keyword, pc->sides_2sided_short))
-	  ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD, "sides",
-		       NULL, "two-sided-short-edge");
-      }
-
-      if (doc_handling_sup &&
- 	  (keyword = cupsGetOption("collate", num_options, options)) != NULL)
-      {
-        if (!_cups_strcasecmp(keyword, "true"))
-	  collate_str = "separate-documents-collated-copies";
-	else
-	  collate_str = "separate-documents-uncollated-copies";
-
-        for (i = 0; i < doc_handling_sup->num_values; i ++)
-	  if (!strcmp(doc_handling_sup->values[i].string.text, collate_str))
-	  {
-	    ippAddString(request, IPP_TAG_JOB, IPP_TAG_KEYWORD,
-			 "multiple-document-handling", NULL, collate_str);
-	    break;
-          }
-      }
-    }
-    else
-    {
-     /*
-      * When talking to another CUPS server, send all options...
-      */
-
-      cupsEncodeOptions(request, num_options, options);
-    }
-
-    if (copies > 1)
-      ippAddInteger(request, IPP_TAG_JOB, IPP_TAG_INTEGER, "copies", copies);
-  }
-
-  return (request);
-}
-
-
-/*
  * 'password_cb()' - Disable the password prompt for cupsDoFileRequest().
  */
 
@@ -2356,11 +1592,10 @@
 static void
 report_attr(ipp_attribute_t *attr)	/* I - Attribute */
 {
-  int		i;			/* Looping var */
-  char		value[1024],		/* Value string */
-		*valptr,		/* Pointer into value string */
-		*attrptr;		/* Pointer into attribute value */
-  const char	*cached;		/* Cached attribute */
+  int	i;				/* Looping var */
+  char	value[1024],			/* Value string */
+	*valptr,			/* Pointer into value string */
+	*attrptr;			/* Pointer into attribute value */
 
 
  /*
@@ -2410,21 +1645,11 @@
 
   *valptr = '\0';
 
-  _cupsMutexLock(&report_mutex);
+ /*
+  * Tell the scheduler about the new values...
+  */
 
-  if ((cached = cupsGetOption(attr->name, num_attr_cache,
-                              attr_cache)) == NULL || strcmp(cached, value))
-  {
-   /*
-    * Tell the scheduler about the new values...
-    */
-
-    num_attr_cache = cupsAddOption(attr->name, value, num_attr_cache,
-                                   &attr_cache);
-    fprintf(stderr, "ATTR: %s=%s\n", attr->name, value);
-  }
-
-  _cupsMutexUnlock(&report_mutex);
+  fprintf(stderr, "ATTR: %s=%s\n", attr->name, value);
 }
 
 
@@ -2432,561 +1657,297 @@
  * 'report_printer_state()' - Report the printer state.
  */
 
-static void
-report_printer_state(ipp_t *ipp)	/* I - IPP response */
+static int				/* O - Number of reasons shown */
+report_printer_state(ipp_t *ipp,	/* I - IPP response */
+                     int   job_id)	/* I - Current job ID */
 {
-  ipp_attribute_t	*pa,		/* printer-alert */
-			*pam,		/* printer-alert-message */
+  int			i;		/* Looping var */
+  int			count;		/* Count of reasons shown... */
+  ipp_attribute_t	*caprm,		/* com.apple.print.recoverable-message */
 			*psm,		/* printer-state-message */
 			*reasons,	/* printer-state-reasons */
 			*marker;	/* marker-* attributes */
-  char			value[1024],	/* State/message string */
-			*valptr;	/* Pointer into string */
-  static int		ipp_supplies = -1;
-					/* Report supply levels? */
+  const char		*reason;	/* Current reason */
+  const char		*prefix;	/* Prefix for STATE: line */
+  char			state[1024];	/* State string */
+  int			saw_caprw;	/* Saw com.apple.print.recoverable-warning state */
 
 
- /*
-  * Report alerts and messages...
-  */
+  if ((psm = ippFindAttribute(ipp, "printer-state-message",
+                              IPP_TAG_TEXT)) != NULL)
+    fprintf(stderr, "INFO: %s\n", psm->values[0].string.text);
 
-  if ((pa = ippFindAttribute(ipp, "printer-alert", IPP_TAG_TEXT)) != NULL)
-    report_attr(pa);
+  if ((reasons = ippFindAttribute(ipp, "printer-state-reasons",
+                                  IPP_TAG_KEYWORD)) == NULL)
+    return (0);
 
-  if ((pam = ippFindAttribute(ipp, "printer-alert-message",
-                              IPP_TAG_TEXT)) != NULL)
-    report_attr(pam);
+  saw_caprw = 0;
+  state[0]  = '\0';
+  prefix    = "STATE: ";
 
-  if ((psm = ippFindAttribute(ipp, "printer-state-message",
-                              IPP_TAG_TEXT)) != NULL)
+  for (i = 0, count = 0; i < reasons->num_values; i ++)
   {
-    char	*ptr;			/* Pointer into message */
+    reason = reasons->values[i].string.text;
 
-
-    strlcpy(value, "INFO: ", sizeof(value));
-    for (ptr = psm->values[0].string.text, valptr = value + 6;
-         *ptr && valptr < (value + sizeof(value) - 6);
-	 ptr ++)
+    if (!strcmp(reason, "com.apple.print.recoverable-warning"))
+      saw_caprw = 1;
+    else if (strcmp(reason, "paused"))
     {
-      if (*ptr < ' ' && *ptr > 0 && *ptr != '\t')
-      {
-       /*
-        * Substitute "<XX>" for the control character; sprintf is safe because
-	* we always leave 6 chars free at the end...
-	*/
+      strlcat(state, prefix, sizeof(state));
+      strlcat(state, reason, sizeof(state));
 
-        sprintf(valptr, "<%02X>", *ptr);
-	valptr += 4;
-      }
-      else
-        *valptr++ = *ptr;
+      prefix  = ",";
     }
+  }
 
-    *valptr++ = '\n';
-    *valptr   = '\0';
+  if (state[0])
+    fprintf(stderr, "%s\n", state);
 
-    fputs(value, stderr);
-  }
-
  /*
-  * Now report printer-state-reasons, filtering out some of the reasons we never
-  * want to set...
+  * Relay com.apple.print.recoverable-message...
   */
 
-  if ((reasons = ippFindAttribute(ipp, "printer-state-reasons",
-                                  IPP_TAG_KEYWORD)) == NULL)
-    return;
+  if ((caprm = ippFindAttribute(ipp, "com.apple.print.recoverable-message",
+                                IPP_TAG_TEXT)) != NULL)
+    fprintf(stderr, "WARNING: %s: %s\n",
+            saw_caprw ? "recoverable" : "recovered",
+	    caprm->values[0].string.text);
 
-  update_reasons(reasons, NULL);
-
  /*
   * Relay the current marker-* attribute values...
   */
 
-  if (ipp_supplies < 0)
-  {
-    ppd_file_t	*ppd;			/* PPD file */
-    ppd_attr_t	*ppdattr;		/* Attribute in PPD file */
+  if ((marker = ippFindAttribute(ipp, "marker-colors", IPP_TAG_NAME)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-high-levels",
+                                 IPP_TAG_INTEGER)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-levels",
+                                 IPP_TAG_INTEGER)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-low-levels",
+                                 IPP_TAG_INTEGER)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-message", IPP_TAG_TEXT)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-names", IPP_TAG_NAME)) != NULL)
+    report_attr(marker);
+  if ((marker = ippFindAttribute(ipp, "marker-types", IPP_TAG_KEYWORD)) != NULL)
+    report_attr(marker);
 
-    if ((ppd = ppdOpenFile(getenv("PPD"))) != NULL &&
-        (ppdattr = ppdFindAttr(ppd, "cupsIPPSupplies", NULL)) != NULL &&
-        ppdattr->value && _cups_strcasecmp(ppdattr->value, "true"))
-      ipp_supplies = 0;
-    else
-      ipp_supplies = 1;
-
-    ppdClose(ppd);
-  }
-
-  if (ipp_supplies > 0)
-  {
-    if ((marker = ippFindAttribute(ipp, "marker-colors", IPP_TAG_NAME)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-high-levels",
-                                   IPP_TAG_INTEGER)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-levels",
-                                   IPP_TAG_INTEGER)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-low-levels",
-                                   IPP_TAG_INTEGER)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-message",
-                                   IPP_TAG_TEXT)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-names", IPP_TAG_NAME)) != NULL)
-      report_attr(marker);
-    if ((marker = ippFindAttribute(ipp, "marker-types",
-                                   IPP_TAG_KEYWORD)) != NULL)
-      report_attr(marker);
-  }
+  return (count);
 }
 
 
-#if defined(HAVE_GSSAPI) && defined(HAVE_XPC)
+#ifdef __APPLE__
 /*
- * 'run_as_user()' - Run the IPP backend as the printing user.
+ * 'run_pictwps_filter()' - Convert PICT files to PostScript when printing
+ *                          remotely.
  *
- * This function uses an XPC-based user agent to run the backend as the printing
- * user. We need to do this in order to have access to the user's Kerberos
- * credentials.
+ * This step is required because the PICT format is not documented and
+ * subject to change, so developing a filter for other OS's is infeasible.
+ * Also, fonts required by the PICT file need to be embedded on the
+ * client side (which has the fonts), so we run the filter to get a
+ * PostScript file for printing...
  */
 
-static int				/* O - Exit status */
-run_as_user(int        argc,		/* I - Number of command-line args */
-	    char       *argv[],		/* I - Command-line arguments */
-	    uid_t      uid,		/* I - User ID */
-	    const char *device_uri,	/* I - Device URI */
-	    int        fd)		/* I - File to print */
+static int				/* O - Exit status of filter */
+run_pictwps_filter(char       **argv,	/* I - Command-line arguments */
+                   const char *filename)/* I - Filename */
 {
-  const char		*auth_negotiate;/* AUTH_NEGOTIATE env var */
-  xpc_connection_t	conn;		/* Connection to XPC service */
-  xpc_object_t		request;	/* Request message dictionary */
-  __block xpc_object_t	response;	/* Response message dictionary */
-  dispatch_semaphore_t	sem;		/* Semaphore for waiting for response */
-  int			status = CUPS_BACKEND_FAILED;
-					/* Status of request */
+  struct stat	fileinfo;		/* Print file information */
+  const char	*ppdfile;		/* PPD file for destination printer */
+  int		pid;			/* Child process ID */
+  int		fd;			/* Temporary file descriptor */
+  int		status;			/* Exit status of filter */
+  const char	*printer;		/* PRINTER env var */
+  static char	ppdenv[1024];		/* PPD environment variable */
 
 
-  fprintf(stderr, "DEBUG: Running IPP backend as UID %d.\n", (int)uid);
-
  /*
-  * Connect to the user agent for the specified UID...
+  * First get the PPD file for the printer...
   */
 
-  conn = xpc_connection_create_mach_service(kPMPrintUIToolAgent,
-                                            dispatch_get_global_queue(0, 0), 0);
-  if (!conn)
+  printer = getenv("PRINTER");
+  if (!printer)
   {
-    _cupsLangPrintFilter(stderr, "ERROR",
-                         _("Unable to start backend process."));
-    fputs("DEBUG: Unable to create connection to agent.\n", stderr);
-    goto cleanup;
+    _cupsLangPuts(stderr,
+                  _("ERROR: PRINTER environment variable not defined!\n"));
+    return (-1);
   }
 
-  xpc_connection_set_event_handler(conn,
-                                   ^(xpc_object_t event)
-				   {
-				     xpc_type_t messageType = xpc_get_type(event);
-
-				     if (messageType == XPC_TYPE_ERROR)
-				     {
-				       if (event == XPC_ERROR_CONNECTION_INTERRUPTED)
-					 fprintf(stderr, "DEBUG: Interrupted connection to service %s.\n",
-					         xpc_connection_get_name(conn));
-				       else if (event == XPC_ERROR_CONNECTION_INVALID)
-				         fprintf(stderr, "DEBUG: Connection invalid for service %s.\n",
-					         xpc_connection_get_name(conn));
-				       else
-				         fprintf(stderr, "DEBUG: Unxpected error for service %s: %s\n",
-					         xpc_connection_get_name(conn),
-						 xpc_dictionary_get_string(event, XPC_ERROR_KEY_DESCRIPTION));
-				     }
-				   });
-  xpc_connection_set_target_uid(conn, uid);
-  xpc_connection_resume(conn);
-
- /*
-  * Try starting the backend...
-  */
-
-  request = xpc_dictionary_create(NULL, NULL, 0);
-  xpc_dictionary_set_int64(request, "command", kPMStartJob);
-  xpc_dictionary_set_string(request, "device-uri", device_uri);
-  xpc_dictionary_set_string(request, "job-id", argv[1]);
-  xpc_dictionary_set_string(request, "user", argv[2]);
-  xpc_dictionary_set_string(request, "title", argv[3]);
-  xpc_dictionary_set_string(request, "copies", argv[4]);
-  xpc_dictionary_set_string(request, "options", argv[5]);
-  xpc_dictionary_set_string(request, "auth-info-required",
-                            getenv("AUTH_INFO_REQUIRED"));
-  if ((auth_negotiate = getenv("AUTH_NEGOTIATE")) != NULL)
-    xpc_dictionary_set_string(request, "auth-negotiate", auth_negotiate);
-  xpc_dictionary_set_fd(request, "stdin", fd);
-  xpc_dictionary_set_fd(request, "stderr", 2);
-  xpc_dictionary_set_fd(request, "side-channel", CUPS_SC_FD);
-
-  sem      = dispatch_semaphore_create(0);
-  response = NULL;
-
-  xpc_connection_send_message_with_reply(conn, request,
-                                         dispatch_get_global_queue(0,0),
-					 ^(xpc_object_t reply)
-					 {
-					   /* Save the response and wake up */
-					   if (xpc_get_type(reply)
-					           == XPC_TYPE_DICTIONARY)
-					     response = xpc_retain(reply);
-
-					   dispatch_semaphore_signal(sem);
-					 });
-
-  dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
-  xpc_release(request);
-  dispatch_release(sem);
-
-  if (response)
+  if ((ppdfile = cupsGetPPD(printer)) == NULL)
   {
-    child_pid = xpc_dictionary_get_int64(response, "child-pid");
-
-    xpc_release(response);
-
-    if (child_pid)
-      fprintf(stderr, "DEBUG: Child PID=%d.\n", child_pid);
-    else
-    {
-      _cupsLangPrintFilter(stderr, "ERROR",
-                           _("Unable to start backend process."));
-      fputs("DEBUG: No child PID.\n", stderr);
-      goto cleanup;
-    }
+    _cupsLangPrintf(stderr,
+		    _("ERROR: Unable to get PPD file for printer \"%s\" - "
+		      "%s.\n"), printer, cupsLastErrorString());
   }
   else
   {
-    _cupsLangPrintFilter(stderr, "ERROR",
-                         _("Unable to start backend process."));
-    fputs("DEBUG: No reply from agent.\n", stderr);
-    goto cleanup;
+    snprintf(ppdenv, sizeof(ppdenv), "PPD=%s", ppdfile);
+    putenv(ppdenv);
   }
 
  /*
-  * Then wait for the backend to finish...
+  * Then create a temporary file for printing...
   */
 
-  request = xpc_dictionary_create(NULL, NULL, 0);
-  xpc_dictionary_set_int64(request, "command", kPMWaitForJob);
-  xpc_dictionary_set_fd(request, "stderr", 2);
-
-  sem      = dispatch_semaphore_create(0);
-  response = NULL;
-
-  xpc_connection_send_message_with_reply(conn, request,
-                                         dispatch_get_global_queue(0,0),
-					 ^(xpc_object_t reply)
-					 {
-					   /* Save the response and wake up */
-					   if (xpc_get_type(reply)
-					           == XPC_TYPE_DICTIONARY)
-					     response = xpc_retain(reply);
-
-					   dispatch_semaphore_signal(sem);
-					 });
-
-  dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
-  xpc_release(request);
-  dispatch_release(sem);
-
-  if (response)
+  if ((fd = cupsTempFd(pstmpname, sizeof(pstmpname))) < 0)
   {
-    status = xpc_dictionary_get_int64(response, "status");
+    _cupsLangPrintError(_("ERROR: Unable to create temporary file"));
+    if (ppdfile)
+      unlink(ppdfile);
+    return (-1);
+  }
 
-    if (status == SIGTERM || status == SIGKILL || status == SIGPIPE)
-    {
-      fprintf(stderr, "DEBUG: Child terminated on signal %d.\n", status);
-      status = CUPS_BACKEND_FAILED;
-    }
-    else if (WIFSIGNALED(status))
-    {
-      fprintf(stderr, "DEBUG: Child crashed on signal %d.\n", status);
-      status = CUPS_BACKEND_STOP;
-    }
-    else if (WIFEXITED(status))
-    {
-      status = WEXITSTATUS(status);
-      fprintf(stderr, "DEBUG: Child exited with status %d.\n", status);
-    }
+ /*
+  * Get the owner of the spool file - it is owned by the user we want to run
+  * as...
+  */
 
-    xpc_release(response);
-  }
+  if (argv[6])
+    stat(argv[6], &fileinfo);
   else
-    _cupsLangPrintFilter(stderr, "ERROR",
-                         _("Unable to get backend exit status."));
+  {
+   /*
+    * Use the OSX defaults, as an up-stream filter created the PICT
+    * file...
+    */
 
-  cleanup:
-
-  if (conn)
-  {
-    xpc_connection_suspend(conn);
-    xpc_connection_cancel(conn);
-    xpc_release(conn);
+    fileinfo.st_uid = 1;
+    fileinfo.st_gid = 80;
   }
 
-  return (status);
-}
-#endif /* HAVE_GSSAPI && HAVE_XPC */
+  if (ppdfile)
+    chown(ppdfile, fileinfo.st_uid, fileinfo.st_gid);
 
+  fchown(fd, fileinfo.st_uid, fileinfo.st_gid);
 
-/*
- * 'sigterm_handler()' - Handle 'terminate' signals that stop the backend.
- */
+ /*
+  * Finally, run the filter to convert the file...
+  */
 
-static void
-sigterm_handler(int sig)		/* I - Signal */
-{
-  (void)sig;	/* remove compiler warnings... */
-
-#if defined(HAVE_GSSAPI) && defined(HAVE_XPC)
-  if (child_pid)
+  if ((pid = fork()) == 0)
   {
-    kill(child_pid, sig);
-    child_pid = 0;
-  }
-#endif /* HAVE_GSSAPI && HAVE_XPC */
-
-  if (!job_canceled)
-  {
    /*
-    * Flag that the job should be canceled...
+    * Child process for pictwpstops...  Redirect output of pictwpstops to a
+    * file...
     */
 
-    job_canceled = 1;
-    return;
-  }
+    dup2(fd, 1);
+    close(fd);
 
- /*
-  * The scheduler already tried to cancel us once, now just terminate
-  * after removing our temp file!
-  */
+    if (!getuid())
+    {
+     /*
+      * Change to an unpriviledged user...
+      */
 
-  if (tmpfilename[0])
-    unlink(tmpfilename);
+      if (setgid(fileinfo.st_gid))
+        return (errno);
 
-  exit(1);
-}
+      if (setuid(fileinfo.st_uid))
+        return (errno);
+    }
 
+    execlp("pictwpstops", printer, argv[1], argv[2], argv[3], argv[4], argv[5],
+           filename, NULL);
+    _cupsLangPrintf(stderr, _("ERROR: Unable to exec pictwpstops: %s\n"),
+		    strerror(errno));
+    return (errno);
+  }
 
-/*
- * 'timeout_cb()' - Handle HTTP timeouts.
- */
+  close(fd);
 
-static int				/* O - 1 to continue, 0 to cancel */
-timeout_cb(http_t *http,		/* I - Connection to server (unused) */
-           void   *user_data)		/* I - User data (unused) */
-{
-  (void)http;
-  (void)user_data;
+  if (pid < 0)
+  {
+   /*
+    * Error!
+    */
 
-  return (!job_canceled);
-}
+    _cupsLangPrintf(stderr, _("ERROR: Unable to fork pictwpstops: %s\n"),
+		    strerror(errno));
+    if (ppdfile)
+      unlink(ppdfile);
+    return (-1);
+  }
 
-
-/*
- * 'update_reasons()' - Update the printer-state-reasons values.
- */
-
-static void
-update_reasons(ipp_attribute_t *attr,	/* I - printer-state-reasons or NULL */
-               const char      *s)	/* I - STATE: string or NULL */
-{
-  char		op;			/* Add (+), remove (-), replace (\0) */
-  cups_array_t	*new_reasons;		/* New reasons array */
-  char		*reason,		/* Current reason */
-		add[2048],		/* Reasons added string */
-		*addptr,		/* Pointer into add string */
-		rem[2048],		/* Reasons removed string */
-		*remptr;		/* Pointer into remove string */
-  const char	*addprefix,		/* Current add string prefix */
-		*remprefix;		/* Current remove string prefix */
-
-
-  fprintf(stderr, "DEBUG: update_reasons(attr=%d(%s%s), s=\"%s\")\n",
-	  attr ? attr->num_values : 0, attr ? attr->values[0].string.text : "",
-	  attr && attr->num_values > 1 ? ",..." : "", s ? s : "(null)");
-
  /*
-  * Create an array of new reason keyword strings...
+  * Now wait for the filter to complete...
   */
 
-  if (attr)
+  if (wait(&status) < 0)
   {
-    int	i;				/* Looping var */
+    _cupsLangPrintf(stderr, _("ERROR: Unable to wait for pictwpstops: %s\n"),
+		    strerror(errno));
+    close(fd);
+    if (ppdfile)
+      unlink(ppdfile);
+    return (-1);
+  }
 
-    new_reasons = cupsArrayNew((cups_array_func_t)strcmp, NULL);
-    op          = '\0';
+  if (ppdfile)
+    unlink(ppdfile);
 
-    for (i = 0; i < attr->num_values; i ++)
-    {
-      reason = attr->values[i].string.text;
+  close(fd);
 
-      if (strcmp(reason, "none") &&
-	  strcmp(reason, "none-report") &&
-	  strcmp(reason, "paused") &&
-	  strncmp(reason, "spool-area-full", 15) &&
-	  strcmp(reason, "com.apple.print.recoverable-warning") &&
-	  strncmp(reason, "cups-", 5))
-	cupsArrayAdd(new_reasons, reason);
-    }
-  }
-  else if (s)
+  if (status)
   {
-    if (*s == '+' || *s == '-')
-      op = *s++;
+    if (status >= 256)
+      _cupsLangPrintf(stderr, _("ERROR: pictwpstops exited with status %d!\n"),
+		      status / 256);
     else
-      op = '\0';
+      _cupsLangPrintf(stderr, _("ERROR: pictwpstops exited on signal %d!\n"),
+		      status);
 
-    new_reasons = _cupsArrayNewStrings(s);
+    return (status);
   }
-  else
-    return;
 
  /*
-  * Compute the changes...
+  * Return with no errors..
   */
 
-  add[0]    = '\0';
-  addprefix = "STATE: +";
-  addptr    = add;
-  rem[0]    = '\0';
-  remprefix = "STATE: -";
-  remptr    = rem;
+  return (0);
+}
+#endif /* __APPLE__ */
 
-  fprintf(stderr, "DEBUG2: op='%c', new_reasons=%d, state_reasons=%d\n",
-          op ? op : ' ', cupsArrayCount(new_reasons),
-	  cupsArrayCount(state_reasons));
 
-  _cupsMutexLock(&report_mutex);
+/*
+ * 'sigterm_handler()' - Handle 'terminate' signals that stop the backend.
+ */
 
-  if (op == '+')
-  {
-   /*
-    * Add reasons...
-    */
+static void
+sigterm_handler(int sig)		/* I - Signal */
+{
+  (void)sig;	/* remove compiler warnings... */
 
-    for (reason = (char *)cupsArrayFirst(new_reasons);
-	 reason;
-	 reason = (char *)cupsArrayNext(new_reasons))
-    {
-      if (!cupsArrayFind(state_reasons, reason))
-      {
-        if (!strncmp(reason, "cups-remote-", 12))
-	{
-	 /*
-	  * If we are setting cups-remote-xxx, remove all other cups-remote-xxx
-	  * keywords...
-	  */
-
-	  char	*temp;		/* Current reason in state_reasons */
-
-	  cupsArraySave(state_reasons);
-
-	  for (temp = (char *)cupsArrayFirst(state_reasons);
-	       temp;
-	       temp = (char *)cupsArrayNext(state_reasons))
-	    if (!strncmp(temp, "cups-remote-", 12))
-	    {
-	      snprintf(remptr, sizeof(rem) - (remptr - rem), "%s%s", remprefix,
-	               temp);
-	      remptr    += strlen(remptr);
-	      remprefix = ",";
-
-	      cupsArrayRemove(state_reasons, temp);
-	      break;
-	    }
-
-	  cupsArrayRestore(state_reasons);
-	}
-
-        cupsArrayAdd(state_reasons, reason);
-
-        snprintf(addptr, sizeof(add) - (addptr - add), "%s%s", addprefix,
-	         reason);
-	addptr    += strlen(addptr);
-	addprefix = ",";
-      }
-    }
-  }
-  else if (op == '-')
+  if (!job_cancelled)
   {
    /*
-    * Remove reasons...
+    * Flag that the job should be cancelled...
     */
 
-    for (reason = (char *)cupsArrayFirst(new_reasons);
-	 reason;
-	 reason = (char *)cupsArrayNext(new_reasons))
-    {
-      if (cupsArrayFind(state_reasons, reason))
-      {
-	snprintf(remptr, sizeof(rem) - (remptr - rem), "%s%s", remprefix,
-		 reason);
-	remptr    += strlen(remptr);
-	remprefix = ",";
-
-        cupsArrayRemove(state_reasons, reason);
-      }
-    }
+    job_cancelled = 1;
+    return;
   }
-  else
-  {
-   /*
-    * Replace reasons...
-    */
 
-    for (reason = (char *)cupsArrayFirst(state_reasons);
-	 reason;
-	 reason = (char *)cupsArrayNext(state_reasons))
-    {
-      if (strncmp(reason, "cups-", 5) && !cupsArrayFind(new_reasons, reason))
-      {
-	snprintf(remptr, sizeof(rem) - (remptr - rem), "%s%s", remprefix,
-		 reason);
-	remptr    += strlen(remptr);
-	remprefix = ",";
+ /*
+  * The scheduler already tried to cancel us once, now just terminate
+  * after removing our temp files!
+  */
 
-        cupsArrayRemove(state_reasons, reason);
-      }
-    }
+  if (tmpfilename[0])
+    unlink(tmpfilename);
 
-    for (reason = (char *)cupsArrayFirst(new_reasons);
-	 reason;
-	 reason = (char *)cupsArrayNext(new_reasons))
-    {
-      if (!cupsArrayFind(state_reasons, reason))
-      {
-        cupsArrayAdd(state_reasons, reason);
+#ifdef __APPLE__
+  if (pstmpname[0])
+    unlink(pstmpname);
+#endif /* __APPLE__ */
 
-        snprintf(addptr, sizeof(add) - (addptr - add), "%s%s", addprefix,
-	         reason);
-	addptr    += strlen(addptr);
-	addprefix = ",";
-      }
-    }
-  }
+  exit(1);
+}
 
-  _cupsMutexUnlock(&report_mutex);
 
- /*
-  * Report changes and return...
-  */
-
-  if (add[0] && rem[0])
-    fprintf(stderr, "%s\n%s\n", add, rem);
-  else if (add[0])
-    fprintf(stderr, "%s\n", add);
-  else if (rem[0])
-    fprintf(stderr, "%s\n", rem);
-}
-
 /*
  * End of "$Id$".
  */
